<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Matrice Blocs - Rubik's</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        body { background: #12131a; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 20px; }
        
        .container {
            position: relative;
            width: 300px;
            height: 400px;
            overflow: hidden;
        }
        
        .cells-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }
        
        .cell {
            position: absolute;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .cell svg {
            width: 80%;
            height: 80%;
        }
        
        svg .icon { 
            stroke: rgba(180,180,190,0.35); 
            stroke-width: 1.5; 
            stroke-linecap: round; 
            stroke-linejoin: round; 
            fill: none; 
        }
        svg .point { 
            fill: rgba(180,180,190,0.35); 
            stroke: none; 
        }
        
        /* === ÉTATS === */
        /* WHITE (défaut) */
        svg .icon.white { stroke: rgba(180,180,190,0.35); }
        svg .point.white { fill: rgba(180,180,190,0.35); }
        
        /* SILVER */
        svg .icon.silver { 
            stroke: #22d3ee; 
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); 
        }
        svg .point.silver { 
            fill: #22d3ee; 
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); 
        }
        
        /* GOLD */
        svg .icon.gold { 
            stroke: #ffd700; 
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); 
        }
        svg .point.gold { 
            fill: #ffd700; 
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); 
        }
        
        /* EMERALD */
        svg .icon.emerald { 
            stroke: #34d399; 
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)) drop-shadow(0 0 12px rgba(5, 150, 105, 0.5)); 
        }
        svg .point.emerald { 
            fill: #34d399; 
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)); 
        }
        
        /* COSMIC */
        svg .icon.cosmic { 
            stroke: #c4b5fd; 
            filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)) drop-shadow(0 0 10px rgba(255, 0, 110, 0.4)); 
            animation: cosmicShift 3s ease-in-out infinite;
        }
        svg .point.cosmic { 
            fill: #c4b5fd; 
            filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)); 
            animation: cosmicPulse 1.5s ease-in-out infinite;
        }
        
        /* SUPERNOVAE */
        svg .icon.supernovae { 
            stroke: #fff; 
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.9)) 
                    drop-shadow(0 0 16px rgba(255, 200, 100, 0.7)) 
                    drop-shadow(0 0 24px rgba(255, 100, 50, 0.5)); 
            animation: supernovaeFlare 2s ease-in-out infinite;
        }
        svg .point.supernovae { 
            fill: #fff; 
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.9)) 
                    drop-shadow(0 0 16px rgba(255, 200, 100, 0.7)); 
            animation: supernovaePulse 1s ease-in-out infinite;
        }
        
        @keyframes cosmicShift {
            0%, 100% { stroke: #c4b5fd; }
            50% { stroke: #f0abfc; }
        }
        @keyframes cosmicPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        @keyframes supernovaeFlare {
            0%, 100% { filter: drop-shadow(0 0 8px rgba(255,255,255,0.9)) drop-shadow(0 0 16px rgba(255,200,100,0.7)) drop-shadow(0 0 24px rgba(255,100,50,0.5)); }
            50% { filter: drop-shadow(0 0 12px rgba(255,255,255,1)) drop-shadow(0 0 24px rgba(255,200,100,0.9)) drop-shadow(0 0 36px rgba(255,100,50,0.7)); }
        }
        @keyframes supernovaePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .lines-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        
        .line-h, .line-v {
            position: absolute;
            background: rgba(180,180,190,0.35);
        }
        
        .line-h {
            height: 1px;
            width: 50px;
        }
        
        .line-v {
            width: 1px;
            height: 50px;
        }
        
        .border-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border: 1px solid rgba(180,180,190,0.35);
            pointer-events: none;
        }
        
        .touch-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .touch-zone {
            position: absolute;
            width: 50px;
            height: 50px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .rotation-group {
            position: absolute;
            width: 100px;
            height: 100px;
            pointer-events: none;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .rotation-group .cell,
        .rotation-group .line-h,
        .rotation-group .line-v {
            position: absolute;
        }
        
        /* Ghosts pour le drag */
        .cell.ghost, .line-h.ghost, .line-v.ghost {
            opacity: 0.7;
        }
        
        /* Slider */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            color: rgba(180,180,190,0.5);
            font-family: system-ui, sans-serif;
            font-size: 12px;
        }
        
        .slider {
            -webkit-appearance: none;
            width: 200px;
            height: 4px;
            background: rgba(180,180,190,0.2);
            border-radius: 2px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: rgba(180,180,190,0.6);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: rgba(180,180,190,0.6);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .slider-value {
            width: 36px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <div class="cells-layer" id="cellsLayer"></div>
        <div class="lines-layer" id="linesLayer"></div>
        <div class="border-layer" id="borderLayer"></div>
        <div class="touch-layer" id="touchLayer"></div>
    </div>
    
    <div class="slider-container">
        <span>Grille</span>
        <input type="range" class="slider" id="gridOpacity" min="0" max="100" value="20">
        <span class="slider-value" id="opacityValue">20%</span>
    </div>
    
    <script>
        const COLS = 6, ROWS = 8;
        const CELL = 50;
        
        // Nouveaux sigles à symétrie rotationnelle d'ordre 4
        const ICONS = {
            spiral: {
                paths: [
                    'M50 50 L50 15 Q50 5 40 10 L20 20',
                    'M50 50 L85 50 Q95 50 90 40 L80 20',
                    'M50 50 L50 85 Q50 95 60 90 L80 80',
                    'M50 50 L15 50 Q5 50 10 60 L20 80'
                ]
            },
            star4: {
                paths: ['M50 10 Q35 35 10 50 Q35 65 50 90 Q65 65 90 50 Q65 35 50 10 Z']
            },
            waves: {
                paths: [
                    'M15 50 Q30 35 50 35 Q70 35 85 50',
                    'M15 50 Q30 65 50 65 Q70 65 85 50',
                    'M50 15 Q35 30 35 50 Q35 70 50 85',
                    'M50 15 Q65 30 65 50 Q65 70 50 85'
                ]
            },
            arrows: {
                paths: [
                    'M20 20 L50 40 L40 50 L20 20',
                    'M80 20 L60 50 L50 40 L80 20',
                    'M80 80 L50 60 L60 50 L80 80',
                    'M20 80 L40 50 L50 60 L20 80'
                ]
            },
            flower: {
                paths: [
                    'M50 50 Q30 30 50 15 Q70 30 50 50',
                    'M50 50 Q70 30 85 50 Q70 70 50 50',
                    'M50 50 Q70 70 50 85 Q30 70 50 50',
                    'M50 50 Q30 70 15 50 Q30 30 50 50'
                ]
            },
            box: {
                paths: [
                    'M35 35 L65 35 L65 65 L35 65 Z',
                    'M35 35 L20 20',
                    'M65 35 L80 20',
                    'M65 65 L80 80',
                    'M35 65 L20 80'
                ]
            },
            corners: {
                circles: [[25,25,10], [75,25,10], [75,75,10], [25,75,10]],
                fills: [[50,50,5]]
            },
            helix: {
                paths: [
                    'M50 50 C50 35 35 20 20 25',
                    'M50 50 C65 50 80 35 75 20',
                    'M50 50 C50 65 65 80 80 75',
                    'M50 50 C35 50 20 65 25 80'
                ]
            },
            diamond: {
                paths: [
                    'M50 30 L70 50 L50 70 L30 50 Z',
                    'M50 30 L50 12',
                    'M70 50 L88 50',
                    'M50 70 L50 88',
                    'M30 50 L12 50'
                ]
            },
            dots: {
                fills: [[50,20,4], [35,28,3], [80,50,4], [72,35,3], [50,80,4], [65,72,3], [20,50,4], [28,65,3]]
            },
            cross: {
                paths: ['M40 15 Q40 40 15 40', 'M60 15 Q60 40 85 40', 'M85 60 Q60 60 60 85', 'M15 60 Q40 60 40 85']
            },
            vortex: {
                paths: [
                    'M50 50 Q45 40 50 25 Q60 30 55 45',
                    'M50 50 Q60 45 75 50 Q70 60 55 55',
                    'M50 50 Q55 60 50 75 Q40 70 45 55',
                    'M50 50 Q40 55 25 50 Q30 40 45 45'
                ]
            }
        };
        const keys = ['spiral', 'star4', 'waves', 'arrows', 'flower', 'box', 'corners', 'helix', 'diamond', 'dots', 'cross', 'vortex'];
        
        function renderIcon(key, state) {
            const icon = ICONS[key];
            if (!icon) return '';
            const stateClass = state || 'white';
            
            let svg = '';
            
            // Paths (strokes)
            if (icon.paths) {
                icon.paths.forEach(d => {
                    svg += `<path class="icon ${stateClass}" d="${d}"/>`;
                });
            }
            
            // Circles (strokes)
            if (icon.circles) {
                icon.circles.forEach(([cx, cy, r]) => {
                    svg += `<circle class="icon ${stateClass}" cx="${cx}" cy="${cy}" r="${r}"/>`;
                });
            }
            
            // Fills (points pleins)
            if (icon.fills) {
                icon.fills.forEach(([cx, cy, r]) => {
                    svg += `<circle class="point ${stateClass}" cx="${cx}" cy="${cy}" r="${r}"/>`;
                });
            }
            
            return svg;
        }
        
        const STATES = ['white', 'silver', 'gold', 'emerald', 'cosmic', 'supernovae'];
        
        let cells = [];
        let cellStates = [];  // État de chaque cellule
        let hLines = [];
        let vLines = [];
        let isAnimating = false;
        
        // Drag state
        let dragging = false;
        let dragAxis = null;
        let dragRow = -1, dragCol = -1;
        let startX = 0, startY = 0;
        let offset = 0;
        let dragElements = [];
        let ghostElements = [];
        
        const container = document.getElementById('container');
        const cellsLayer = document.getElementById('cellsLayer');
        const linesLayer = document.getElementById('linesLayer');
        const touchLayer = document.getElementById('touchLayer');
        
        function rng(seed) {
            let s = seed;
            return () => { s = (s * 1103515245 + 12345) & 0x7fffffff; return s / 0x7fffffff; };
        }
        
        function init() {
            const r = rng(42424);
            
            cells = [];
            cellStates = [];
            for (let i = 0; i < COLS * ROWS; i++) {
                cells.push(keys[~~(r() * 12)]);
                // État aléatoire pondéré (plus de white/silver, moins de supernovae)
                const stateRoll = r();
                if (stateRoll < 0.30) cellStates.push('white');
                else if (stateRoll < 0.55) cellStates.push('silver');
                else if (stateRoll < 0.75) cellStates.push('gold');
                else if (stateRoll < 0.88) cellStates.push('emerald');
                else if (stateRoll < 0.96) cellStates.push('cosmic');
                else cellStates.push('supernovae');
            }
            
            hLines = [];
            for (let row = 0; row < ROWS - 1; row++) {
                for (let col = 0; col < COLS; col++) {
                    hLines.push(true);
                }
            }
            
            vLines = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS - 1; col++) {
                    vLines.push(true);
                }
            }
            
            render();
            createTouchZones();
            setupDragListeners();
        }
        
        function render() {
            cellsLayer.innerHTML = '';
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const idx = row * COLS + col;
                    const div = document.createElement('div');
                    div.className = 'cell';
                    div.id = `cell-${col}-${row}`;
                    div.dataset.col = col;
                    div.dataset.row = row;
                    div.style.left = col * CELL + 'px';
                    div.style.top = row * CELL + 'px';
                    div.innerHTML = `<svg viewBox="0 0 100 100">${renderIcon(cells[idx], cellStates[idx])}</svg>`;
                    cellsLayer.appendChild(div);
                }
            }
            
            linesLayer.innerHTML = '';
            
            for (let row = 0; row < ROWS - 1; row++) {
                for (let col = 0; col < COLS; col++) {
                    const idx = row * COLS + col;
                    if (hLines[idx]) {
                        const line = document.createElement('div');
                        line.className = 'line-h';
                        line.id = `hline-${col}-${row}`;
                        line.dataset.col = col;
                        line.dataset.row = row;
                        line.style.left = col * CELL + 'px';
                        line.style.top = (row + 1) * CELL + 'px';
                        linesLayer.appendChild(line);
                    }
                }
            }
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS - 1; col++) {
                    const idx = row * (COLS - 1) + col;
                    if (vLines[idx]) {
                        const line = document.createElement('div');
                        line.className = 'line-v';
                        line.id = `vline-${col}-${row}`;
                        line.dataset.col = col;
                        line.dataset.row = row;
                        line.style.left = (col + 1) * CELL + 'px';
                        line.style.top = row * CELL + 'px';
                        linesLayer.appendChild(line);
                    }
                }
            }
        }
        
        function createTouchZones() {
            touchLayer.innerHTML = '';
            
            for (let br = 0; br < 4; br++) {
                for (let bc = 0; bc < 3; bc++) {
                    const zone = document.createElement('div');
                    zone.className = 'touch-zone block';
                    zone.style.left = (bc * 2 * CELL + CELL / 2) + 'px';
                    zone.style.top = (br * 2 * CELL + CELL / 2) + 'px';
                    zone.dataset.type = 'block';
                    zone.dataset.bc = bc;
                    zone.dataset.br = br;
                    zone.addEventListener('click', handleRotation);
                    touchLayer.appendChild(zone);
                }
            }
            
            for (let ir = 0; ir < 3; ir++) {
                for (let ic = 0; ic < 2; ic++) {
                    const zone = document.createElement('div');
                    zone.className = 'touch-zone mid';
                    zone.style.left = ((ic + 1) * 2 * CELL - CELL / 2) + 'px';
                    zone.style.top = ((ir + 1) * 2 * CELL - CELL / 2) + 'px';
                    zone.dataset.type = 'mid';
                    zone.dataset.ic = ic;
                    zone.dataset.ir = ir;
                    zone.addEventListener('click', handleRotation);
                    touchLayer.appendChild(zone);
                }
            }
        }
        
        function handleRotation(e) {
            if (isAnimating || dragging) return;
            
            const type = e.target.dataset.type;
            
            if (type === 'block') {
                const bc = +e.target.dataset.bc;
                const br = +e.target.dataset.br;
                animateRotation(bc * 2, br * 2, 'block', bc, br);
            } else {
                const ic = +e.target.dataset.ic;
                const ir = +e.target.dataset.ir;
                const c = (ic + 1) * 2 - 1;
                const r = (ir + 1) * 2 - 1;
                animateRotation(c, r, 'mid', ic, ir);
            }
        }
        
        function animateRotation(startCol, startRow, type, param1, param2) {
            isAnimating = true;
            
            const group = document.createElement('div');
            group.className = 'rotation-group';
            group.style.left = startCol * CELL + 'px';
            group.style.top = startRow * CELL + 'px';
            
            const cellCoords = [
                [startCol, startRow],
                [startCol + 1, startRow],
                [startCol, startRow + 1],
                [startCol + 1, startRow + 1]
            ];
            
            cellCoords.forEach(([col, row]) => {
                const original = document.getElementById(`cell-${col}-${row}`);
                if (original) {
                    original.style.visibility = 'hidden';
                    const clone = original.cloneNode(true);
                    clone.style.left = (col - startCol) * CELL + 'px';
                    clone.style.top = (row - startRow) * CELL + 'px';
                    clone.style.visibility = 'visible';
                    group.appendChild(clone);
                }
            });
            
            const hLineCoords = [
                [startCol, startRow],
                [startCol + 1, startRow]
            ];
            
            hLineCoords.forEach(([col, row]) => {
                const original = document.getElementById(`hline-${col}-${row}`);
                if (original) {
                    original.style.visibility = 'hidden';
                    const clone = original.cloneNode(true);
                    clone.style.left = (col - startCol) * CELL + 'px';
                    clone.style.top = (row - startRow + 1) * CELL + 'px';
                    clone.style.visibility = 'visible';
                    group.appendChild(clone);
                }
            });
            
            const vLineCoords = [
                [startCol, startRow],
                [startCol, startRow + 1]
            ];
            
            vLineCoords.forEach(([col, row]) => {
                const original = document.getElementById(`vline-${col}-${row}`);
                if (original) {
                    original.style.visibility = 'hidden';
                    const clone = original.cloneNode(true);
                    clone.style.left = (col - startCol + 1) * CELL + 'px';
                    clone.style.top = (row - startRow) * CELL + 'px';
                    clone.style.visibility = 'visible';
                    group.appendChild(clone);
                }
            });
            
            container.appendChild(group);
            group.offsetHeight;
            group.style.transformOrigin = '50px 50px';
            group.style.transform = 'rotate(90deg)';
            
            setTimeout(() => {
                group.remove();
                
                if (type === 'block') {
                    rotateBlockData(param1, param2);
                } else {
                    rotateMidData(param1, param2);
                }
                
                render();
                isAnimating = false;
            }, 260);
        }
        
        function rotateBlockData(bc, br) {
            const c = bc * 2;
            const r = br * 2;
            
            const tl = r * COLS + c;
            const tr = r * COLS + c + 1;
            const bl = (r + 1) * COLS + c;
            const br_idx = (r + 1) * COLS + c + 1;
            
            // Rotation des icônes
            const temp = cells[tl];
            cells[tl] = cells[bl];
            cells[bl] = cells[br_idx];
            cells[br_idx] = cells[tr];
            cells[tr] = temp;
            
            // Rotation des états
            const tempState = cellStates[tl];
            cellStates[tl] = cellStates[bl];
            cellStates[bl] = cellStates[br_idx];
            cellStates[br_idx] = cellStates[tr];
            cellStates[tr] = tempState;
            
            const hLeft = r * COLS + c;
            const hRight = r * COLS + c + 1;
            const vTop = r * (COLS - 1) + c;
            const vBottom = (r + 1) * (COLS - 1) + c;
            
            const tempLine = hLines[hLeft];
            hLines[hLeft] = vLines[vBottom];
            vLines[vBottom] = hLines[hRight];
            hLines[hRight] = vLines[vTop];
            vLines[vTop] = tempLine;
        }
        
        function rotateMidData(ic, ir) {
            const c = (ic + 1) * 2;
            const r = (ir + 1) * 2;
            
            const tl = (r - 1) * COLS + (c - 1);
            const tr = (r - 1) * COLS + c;
            const bl = r * COLS + (c - 1);
            const br_idx = r * COLS + c;
            
            // Rotation des icônes
            const temp = cells[tl];
            cells[tl] = cells[bl];
            cells[bl] = cells[br_idx];
            cells[br_idx] = cells[tr];
            cells[tr] = temp;
            
            // Rotation des états
            const tempState = cellStates[tl];
            cellStates[tl] = cellStates[bl];
            cellStates[bl] = cellStates[br_idx];
            cellStates[br_idx] = cellStates[tr];
            cellStates[tr] = tempState;
            
            const hLeft = (r - 1) * COLS + (c - 1);
            const hRight = (r - 1) * COLS + c;
            const vTop = (r - 1) * (COLS - 1) + (c - 1);
            const vBottom = r * (COLS - 1) + (c - 1);
            
            const tempLine = hLines[hLeft];
            hLines[hLeft] = vLines[vBottom];
            vLines[vBottom] = hLines[hRight];
            hLines[hRight] = vLines[vTop];
            vLines[vTop] = tempLine;
        }
        
        // === DRAG SYSTEM ===
        
        function setupDragListeners() {
            container.addEventListener('mousedown', dragStart);
            container.addEventListener('touchstart', dragStart, { passive: false });
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('touchmove', dragMove, { passive: false });
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);
        }
        
        function dragStart(e) {
            if (isAnimating) return;
            if (e.target.classList.contains('touch-zone')) return;
            
            const cell = e.target.closest('.cell');
            if (!cell) return;
            
            e.preventDefault();
            
            dragCol = +cell.dataset.col;
            dragRow = +cell.dataset.row;
            dragging = true;
            dragAxis = null;
            offset = 0;
            dragElements = [];
            ghostElements = [];
            
            const pt = e.touches ? e.touches[0] : e;
            startX = pt.clientX;
            startY = pt.clientY;
        }
        
        function dragMove(e) {
            if (!dragging) return;
            e.preventDefault();
            
            const pt = e.touches ? e.touches[0] : e;
            const dx = pt.clientX - startX;
            const dy = pt.clientY - startY;
            
            // Déterminer l'axe
            if (!dragAxis && (Math.abs(dx) > 8 || Math.abs(dy) > 8)) {
                dragAxis = Math.abs(dx) > Math.abs(dy) ? 'h' : 'v';
                collectDragElements();
                createGhosts();
            }
            
            if (!dragAxis) return;
            
            offset = dragAxis === 'h' ? dx : dy;
            updateDragPositions();
        }
        
        function dragEnd(e) {
            if (!dragging) return;
            dragging = false;
            
            if (!dragAxis) return;
            
            const size = CELL;
            const steps = Math.round(offset / size);
            
            if (steps === 0) {
                // Retour à la position initiale
                animateSnapBack();
            } else {
                // Appliquer le décalage
                animateSnapToStep(steps);
            }
        }
        
        function collectDragElements() {
            dragElements = [];
            
            if (dragAxis === 'h') {
                // Collecter toute la rangée
                for (let col = 0; col < COLS; col++) {
                    const cell = document.getElementById(`cell-${col}-${dragRow}`);
                    if (cell) dragElements.push({ el: cell, baseX: col * CELL, baseY: dragRow * CELL, type: 'cell', col, row: dragRow });
                }
                // Lignes H au-dessus et en-dessous de cette rangée
                if (dragRow > 0) {
                    for (let col = 0; col < COLS; col++) {
                        const line = document.getElementById(`hline-${col}-${dragRow - 1}`);
                        if (line) dragElements.push({ el: line, baseX: col * CELL, baseY: dragRow * CELL, type: 'hline', col, row: dragRow - 1 });
                    }
                }
                if (dragRow < ROWS - 1) {
                    for (let col = 0; col < COLS; col++) {
                        const line = document.getElementById(`hline-${col}-${dragRow}`);
                        if (line) dragElements.push({ el: line, baseX: col * CELL, baseY: (dragRow + 1) * CELL, type: 'hline', col, row: dragRow });
                    }
                }
                // Lignes V dans cette rangée
                for (let col = 0; col < COLS - 1; col++) {
                    const line = document.getElementById(`vline-${col}-${dragRow}`);
                    if (line) dragElements.push({ el: line, baseX: (col + 1) * CELL, baseY: dragRow * CELL, type: 'vline', col, row: dragRow });
                }
            } else {
                // Collecter toute la colonne
                for (let row = 0; row < ROWS; row++) {
                    const cell = document.getElementById(`cell-${dragCol}-${row}`);
                    if (cell) dragElements.push({ el: cell, baseX: dragCol * CELL, baseY: row * CELL, type: 'cell', col: dragCol, row });
                }
                // Lignes V à gauche et à droite de cette colonne
                if (dragCol > 0) {
                    for (let row = 0; row < ROWS; row++) {
                        const line = document.getElementById(`vline-${dragCol - 1}-${row}`);
                        if (line) dragElements.push({ el: line, baseX: dragCol * CELL, baseY: row * CELL, type: 'vline', col: dragCol - 1, row });
                    }
                }
                if (dragCol < COLS - 1) {
                    for (let row = 0; row < ROWS; row++) {
                        const line = document.getElementById(`vline-${dragCol}-${row}`);
                        if (line) dragElements.push({ el: line, baseX: (dragCol + 1) * CELL, baseY: row * CELL, type: 'vline', col: dragCol, row });
                    }
                }
                // Lignes H dans cette colonne
                for (let row = 0; row < ROWS - 1; row++) {
                    const line = document.getElementById(`hline-${dragCol}-${row}`);
                    if (line) dragElements.push({ el: line, baseX: dragCol * CELL, baseY: (row + 1) * CELL, type: 'hline', col: dragCol, row });
                }
            }
        }
        
        function createGhosts() {
            ghostElements = [];
            const totalWidth = COLS * CELL;
            const totalHeight = ROWS * CELL;
            
            dragElements.forEach(item => {
                // Créer 2 ghosts (avant et après)
                [-1, 1].forEach(dir => {
                    const ghost = item.el.cloneNode(true);
                    ghost.classList.add('ghost');
                    ghost.id = '';
                    
                    if (dragAxis === 'h') {
                        ghost.style.left = (item.baseX + dir * totalWidth) + 'px';
                        ghost.style.top = item.baseY + 'px';
                        ghostElements.push({ el: ghost, baseX: item.baseX + dir * totalWidth, baseY: item.baseY });
                    } else {
                        ghost.style.left = item.baseX + 'px';
                        ghost.style.top = (item.baseY + dir * totalHeight) + 'px';
                        ghostElements.push({ el: ghost, baseX: item.baseX, baseY: item.baseY + dir * totalHeight });
                    }
                    
                    if (item.type === 'cell') {
                        cellsLayer.appendChild(ghost);
                    } else {
                        linesLayer.appendChild(ghost);
                    }
                });
            });
        }
        
        function updateDragPositions() {
            dragElements.forEach(item => {
                item.el.style.transition = 'none';
                if (dragAxis === 'h') {
                    item.el.style.left = (item.baseX + offset) + 'px';
                } else {
                    item.el.style.top = (item.baseY + offset) + 'px';
                }
            });
            
            ghostElements.forEach(item => {
                item.el.style.transition = 'none';
                if (dragAxis === 'h') {
                    item.el.style.left = (item.baseX + offset) + 'px';
                } else {
                    item.el.style.top = (item.baseY + offset) + 'px';
                }
            });
        }
        
        function animateSnapBack() {
            const prop = dragAxis === 'h' ? 'left' : 'top';
            const base = dragAxis === 'h' ? 'baseX' : 'baseY';
            
            dragElements.forEach(item => {
                item.el.style.transition = `${prop} 0.15s ease-out`;
                item.el.style[prop] = item[base] + 'px';
            });
            
            setTimeout(() => {
                clearGhosts();
                dragAxis = null;
            }, 160);
        }
        
        function animateSnapToStep(steps) {
            const totalSize = dragAxis === 'h' ? COLS * CELL : ROWS * CELL;
            const count = dragAxis === 'h' ? COLS : ROWS;
            const prop = dragAxis === 'h' ? 'left' : 'top';
            const base = dragAxis === 'h' ? 'baseX' : 'baseY';
            
            // Calculer nouvelles positions avec wrap
            dragElements.forEach(item => {
                const origPos = item[base] / CELL;
                const newPos = ((origPos + steps) % count + count) % count;
                const target = newPos * CELL;
                
                // Trouver le chemin le plus court
                let current = item[base] + offset;
                while (current - target > totalSize / 2) current -= totalSize;
                while (target - current > totalSize / 2) current += totalSize;
                
                item.el.style.transition = 'none';
                item.el.style[prop] = current + 'px';
            });
            
            // Forcer reflow
            container.offsetHeight;
            
            // Animer vers la position finale
            dragElements.forEach(item => {
                const origPos = item[base] / CELL;
                const newPos = ((origPos + steps) % count + count) % count;
                const target = newPos * CELL;
                
                item.el.style.transition = `${prop} 0.15s ease-out`;
                item.el.style[prop] = target + 'px';
            });
            
            setTimeout(() => {
                clearGhosts();
                applyDragShift(steps);
                render();
                dragAxis = null;
            }, 160);
        }
        
        function clearGhosts() {
            ghostElements.forEach(item => item.el.remove());
            ghostElements = [];
        }
        
        function applyDragShift(steps) {
            if (dragAxis === 'h') {
                // Décaler la rangée de cellules
                const row = dragRow;
                const newRow = [];
                for (let col = 0; col < COLS; col++) {
                    const srcCol = ((col - steps) % COLS + COLS) % COLS;
                    newRow[col] = cells[row * COLS + srcCol];
                }
                for (let col = 0; col < COLS; col++) {
                    cells[row * COLS + col] = newRow[col];
                }
                
                // Décaler les lignes H au-dessus (row - 1) et en-dessous (row)
                if (row > 0) {
                    const hRow = row - 1;
                    const newH = [];
                    for (let col = 0; col < COLS; col++) {
                        const srcCol = ((col - steps) % COLS + COLS) % COLS;
                        newH[col] = hLines[hRow * COLS + srcCol];
                    }
                    for (let col = 0; col < COLS; col++) {
                        hLines[hRow * COLS + col] = newH[col];
                    }
                }
                if (row < ROWS - 1) {
                    const hRow = row;
                    const newH = [];
                    for (let col = 0; col < COLS; col++) {
                        const srcCol = ((col - steps) % COLS + COLS) % COLS;
                        newH[col] = hLines[hRow * COLS + srcCol];
                    }
                    for (let col = 0; col < COLS; col++) {
                        hLines[hRow * COLS + col] = newH[col];
                    }
                }
                
                // Décaler les lignes V dans cette rangée
                const newV = [];
                for (let col = 0; col < COLS - 1; col++) {
                    const srcCol = ((col - steps) % (COLS - 1) + (COLS - 1)) % (COLS - 1);
                    newV[col] = vLines[row * (COLS - 1) + srcCol];
                }
                for (let col = 0; col < COLS - 1; col++) {
                    vLines[row * (COLS - 1) + col] = newV[col];
                }
                
            } else {
                // Décaler la colonne de cellules
                const col = dragCol;
                const newCol = [];
                for (let row = 0; row < ROWS; row++) {
                    const srcRow = ((row - steps) % ROWS + ROWS) % ROWS;
                    newCol[row] = cells[srcRow * COLS + col];
                }
                for (let row = 0; row < ROWS; row++) {
                    cells[row * COLS + col] = newCol[row];
                }
                
                // Décaler les lignes V à gauche (col - 1) et à droite (col)
                if (col > 0) {
                    const vCol = col - 1;
                    const newV = [];
                    for (let row = 0; row < ROWS; row++) {
                        const srcRow = ((row - steps) % ROWS + ROWS) % ROWS;
                        newV[row] = vLines[srcRow * (COLS - 1) + vCol];
                    }
                    for (let row = 0; row < ROWS; row++) {
                        vLines[row * (COLS - 1) + vCol] = newV[row];
                    }
                }
                if (col < COLS - 1) {
                    const vCol = col;
                    const newV = [];
                    for (let row = 0; row < ROWS; row++) {
                        const srcRow = ((row - steps) % ROWS + ROWS) % ROWS;
                        newV[row] = vLines[srcRow * (COLS - 1) + vCol];
                    }
                    for (let row = 0; row < ROWS; row++) {
                        vLines[row * (COLS - 1) + vCol] = newV[row];
                    }
                }
                
                // Décaler les lignes H dans cette colonne
                const newH = [];
                for (let row = 0; row < ROWS - 1; row++) {
                    const srcRow = ((row - steps) % (ROWS - 1) + (ROWS - 1)) % (ROWS - 1);
                    newH[row] = hLines[srcRow * COLS + col];
                }
                for (let row = 0; row < ROWS - 1; row++) {
                    hLines[row * COLS + col] = newH[row];
                }
            }
        }
        
        init();
        
        // Slider opacité grille
        const gridSlider = document.getElementById('gridOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const linesLayerEl = document.getElementById('linesLayer');
        const borderLayerEl = document.getElementById('borderLayer');
        
        gridSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            opacityValue.textContent = val + '%';
            const opacity = val / 100;
            linesLayerEl.style.opacity = opacity;
            borderLayerEl.style.opacity = opacity;
        });
        
        // Appliquer opacité par défaut
        linesLayerEl.style.opacity = 0.2;
        borderLayerEl.style.opacity = 0.2;
    </script>
</body>
</html>
