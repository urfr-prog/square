<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM - Puzzle Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --cell: min(100px, 31vw);
            --gap: 0px;
        }
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        body {
            background-color: #12131a;
            min-height: 100vh; min-height: -webkit-fill-available;
            display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 8px;
        }
        .logo { display: flex; align-items: center; gap: 3px; height: 32px; cursor: pointer; }
        .logo-icon { width: 28px; height: 28px; }
        .logo-icon svg { width: 100%; height: 100%; }
        .logo-icon svg path, .logo-icon svg line, .logo-icon svg rect, .logo-icon svg polygon {
            stroke: rgba(240, 240, 250, 0.9); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none;
            filter: drop-shadow(0 0 8px rgba(240, 240, 250, 0.4));
        }
        
        /* Barre de score compacte avec inputs */
        .score-bar {
            display: flex; align-items: center; justify-content: space-between; gap: 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(180, 180, 190, 0.2);
            border-radius: 10px; padding: 5px 10px; 
            width: calc(var(--cell) * 3 + var(--gap) * 2);
        }
        .score-item { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .score-item.compact { flex-direction: row; gap: 4px; align-items: center; }
        .score-item.with-input { flex-direction: column; gap: 2px; }
        .score-label { font-size: 0.6rem; color: rgba(180, 180, 190, 0.5); text-transform: uppercase; letter-spacing: 0.05em; }
        .score-value { font-size: 1rem; color: rgba(220, 220, 230, 0.9); font-weight: 500; font-variant-numeric: tabular-nums; }
        .score-value.small { font-size: 0.85rem; }
        .score-value.highlight { animation: scoreFlash 0.5s ease-out; }
        @keyframes scoreFlash { 0% { color: #ffd700; transform: scale(1.2); } 100% { color: rgba(220, 220, 230, 0.9); transform: scale(1); } }
        .combo { color: #34d399 !important; }
        .combo-label { color: #34d399 !important; }
        .stat-icon { font-size: 0.8rem; filter: drop-shadow(0 0 2px currentColor); }
        .stat-icon { font-size: 0.8rem; filter: drop-shadow(0 0 2px currentColor); }
        
        /* Bouton toggle animation points */
        .points-toggle {
            width: 32px; height: 32px; border-radius: 6px; border: 1px solid rgba(34, 211, 238, 0.4);
            background: rgba(34, 211, 238, 0.1); color: rgba(34, 211, 238, 0.6);
            font-size: 0.85rem; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; padding: 0;
        }
        .points-toggle:hover { border-color: rgba(34, 211, 238, 0.7); background: rgba(34, 211, 238, 0.2); }
        .points-toggle.active { 
            border-color: #22d3ee; background: rgba(34, 211, 238, 0.3); color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.4);
        }
        
        /* Conteneur pour grid et layer - AVEC OVERFLOW HIDDEN pour masquage */
        .game-container {
            position: relative;
            width: calc(var(--cell) * 3 + var(--gap) * 2);
            height: calc(var(--cell) * 5 + var(--gap) * 4);
            overflow: hidden; /* MASQUE MAGIQUE pour effet tapis roulant */
        }
        
        /* Layer menu concepteur - positionn√© au-dessus de la grille */
        .settings-layer {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(34, 211, 238, 0.5);
            border-radius: 12px;
            z-index: 100;
        }
        .settings-layer.active {
            display: block;
        }
        
        /* Grille - positionnement absolu des cellules */
        .grid {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(var(--cell) * 3 + var(--gap) * 2);
            height: calc(var(--cell) * 5 + var(--gap) * 4);
        }
        
        .cell {
            width: var(--cell);
            height: var(--cell);
            position: absolute;
        }
        
        .square {
            width: 100%; height: 100%; background-color: transparent;
            border: 1px solid rgba(180, 180, 190, 0.35); border-radius: 12px;
            position: absolute; top: 0; left: 0; overflow: hidden; 
            cursor: grab; user-select: none; touch-action: none;
        }
        .square:hover { border-color: rgba(180, 180, 190, 0.6); }
        .square:active { cursor: grabbing; }
        .square.empty { border-style: dashed; border-color: rgba(180, 180, 190, 0.2); cursor: default; }
        .square.empty:hover { border-color: rgba(180, 180, 190, 0.3); }
        .square.ghost { pointer-events: none; opacity: 0.9; }
        .square svg { width: 100%; height: 100%; }
        svg .separator { stroke-width: 1; }
        svg line.icon, svg path.icon, svg circle.icon, svg rect.icon { stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none; }
        svg .domino-content { 
            transform-origin: 45px 45px; 
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        
        /* BLANC - ic√¥nes m√™me intensit√© que les lignes */
        .square.white { border-color: rgba(180, 180, 190, 0.35); }
        .square.white svg line.icon, .square.white svg path.icon, .square.white svg circle.icon, .square.white svg rect.icon { stroke: rgba(180, 180, 190, 0.35); }
        .square.white svg circle.point { fill: rgba(180, 180, 190, 0.35); }
        .square.white svg .separator { stroke: rgba(180, 180, 190, 0.3); }
        
        /* ARGENT - cyan subtil (ancien diamant mais moins intense) */
        .square.silver { border-color: rgba(6, 182, 212, 0.6); box-shadow: 0 0 12px rgba(6, 182, 212, 0.2), inset 0 0 15px rgba(6, 182, 212, 0.05); }
        .square.silver svg line.icon, .square.silver svg path.icon, .square.silver svg circle.icon, .square.silver svg rect.icon { stroke: #22d3ee; filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); }
        .square.silver svg circle.point { fill: #22d3ee; filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); }
        .square.silver svg .separator { stroke: rgba(34, 211, 238, 0.4); }
        
        /* OR */
        .square.gold { border-color: rgba(255, 215, 0, 0.7); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3), inset 0 0 20px rgba(255, 215, 0, 0.05); }
        .square.gold svg line.icon, .square.gold svg path.icon, .square.gold svg circle.icon, .square.gold svg rect.icon { stroke: #ffd700; filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); }
        .square.gold svg circle.point { fill: #ffd700; filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); }
        .square.gold svg .separator { stroke: rgba(255, 215, 0, 0.4); }
        
        /* √âMERAUDE */
        .square.emerald { border-color: rgba(52, 211, 153, 0.9); box-shadow: 0 0 25px rgba(5, 150, 105, 0.5), 0 0 40px rgba(52, 211, 153, 0.3), inset 0 0 25px rgba(52, 211, 153, 0.1); animation: emeraldGlow 2.5s ease-in-out infinite; }
        .square.emerald svg line.icon, .square.emerald svg path.icon, .square.emerald svg circle.icon, .square.emerald svg rect.icon { stroke: #34d399; filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)) drop-shadow(0 0 12px rgba(5, 150, 105, 0.5)); }
        .square.emerald svg circle.point { fill: #34d399; filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)); }
        .square.emerald svg .separator { stroke: rgba(52, 211, 153, 0.6); }
        @keyframes emeraldGlow {
            0%, 100% { box-shadow: 0 0 25px rgba(5, 150, 105, 0.5), 0 0 40px rgba(52, 211, 153, 0.3), inset 0 0 25px rgba(52, 211, 153, 0.1); }
            50% { box-shadow: 0 0 35px rgba(5, 150, 105, 0.7), 0 0 55px rgba(52, 211, 153, 0.4), inset 0 0 35px rgba(52, 211, 153, 0.15); }
        }
        
        /* COSMIC - Halo mod√©r√© */
        .square.cosmic { border: 2px solid transparent; background: linear-gradient(#12131a, #12131a) padding-box, conic-gradient(from var(--cosmic-angle, 0deg), #ff006e, #8338ec, #06b6d4, #34d399, #ffd700, #ff006e) border-box; box-shadow: 0 0 25px rgba(131, 56, 236, 0.4), 0 0 40px rgba(255, 0, 110, 0.2), 0 0 50px rgba(6, 182, 212, 0.2), inset 0 0 30px rgba(131, 56, 236, 0.1); animation: cosmicRotate 4s linear infinite, cosmicPulse 2s ease-in-out infinite; }
        .square.cosmic svg line.icon, .square.cosmic svg path.icon, .square.cosmic svg circle.icon, .square.cosmic svg rect.icon { stroke: #c4b5fd; filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)) drop-shadow(0 0 10px rgba(255, 0, 110, 0.4)); animation: cosmicIconShift 3s ease-in-out infinite; }
        .square.cosmic svg circle.point { fill: #c4b5fd; filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)); animation: cosmicPointPulse 1.5s ease-in-out infinite; }
        .square.cosmic svg .separator { stroke: rgba(196, 181, 253, 0.6); }
        @property --cosmic-angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes cosmicRotate { to { --cosmic-angle: 360deg; } }
        @keyframes cosmicPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(131, 56, 236, 0.4), 0 0 40px rgba(255, 0, 110, 0.2), 0 0 50px rgba(6, 182, 212, 0.2), inset 0 0 30px rgba(131, 56, 236, 0.1); }
            50% { box-shadow: 0 0 35px rgba(131, 56, 236, 0.6), 0 0 55px rgba(255, 0, 110, 0.35), 0 0 70px rgba(6, 182, 212, 0.3), inset 0 0 40px rgba(131, 56, 236, 0.15); }
        }
        @keyframes cosmicIconShift { 0%, 100% { stroke: #c4b5fd; } 33% { stroke: #22d3ee; } 66% { stroke: #f472b6; } }
        @keyframes cosmicPointPulse { 0%, 100% { fill: #c4b5fd; } 50% { fill: #f472b6; } }
        
        /* SUPERNOVAE - Surface solaire en fusion */
        .square.supernovae { border: 3px solid transparent; background: linear-gradient(#12131a, #12131a) padding-box, conic-gradient(from var(--supernova-angle, 0deg), #ff4500, #ff8c00, #ffd700, #ffff00, #ff8c00, #ff4500) border-box; box-shadow: 0 0 25px rgba(255, 140, 0, 0.4), 0 0 40px rgba(255, 69, 0, 0.2), 0 0 50px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 140, 0, 0.1); animation: supernovaRotate 3s linear infinite, supernovaPulse 1.5s ease-in-out infinite; }
        .square.supernovae svg line.icon, .square.supernovae svg path.icon, .square.supernovae svg circle.icon, .square.supernovae svg rect.icon { stroke: #ffeb3b; filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7)) drop-shadow(0 0 10px rgba(255, 140, 0, 0.4)); animation: supernovaIconShift 2.5s ease-in-out infinite; }
        .square.supernovae svg circle.point { fill: #ffeb3b; filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7)); animation: supernovaPointPulse 1.2s ease-in-out infinite; }
        .square.supernovae svg .separator { stroke: rgba(255, 235, 59, 0.6); }
        @property --supernova-angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes supernovaRotate { to { --supernova-angle: 360deg; } }
        @keyframes supernovaPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(255, 140, 0, 0.4), 0 0 40px rgba(255, 69, 0, 0.2), 0 0 50px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 140, 0, 0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 140, 0, 0.6), 0 0 55px rgba(255, 69, 0, 0.35), 0 0 70px rgba(255, 215, 0, 0.3), inset 0 0 40px rgba(255, 140, 0, 0.15); }
        }
        @keyframes supernovaIconShift { 
            0%, 100% { stroke: #ffeb3b; } 
            25% { stroke: #ff8c00; } 
            50% { stroke: #ffd700; } 
            75% { stroke: #ff6347; } 
        }
        @keyframes supernovaPointPulse { 
            0%, 100% { fill: #ffeb3b; } 
            33% { fill: #ff8c00; } 
            66% { fill: #ffd700; } 
        }
        
        .square.fusing { transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease; }
        
        .controls { display: flex; gap: 8px; width: calc(var(--cell) * 3 + var(--gap) * 2); justify-content: space-between; }
        .level-selector { display: flex; gap: 6px; }
        .level-btn {
            width: 34px; height: 34px; display: flex; align-items: center; justify-content: center;
            background: transparent; border: 1px solid rgba(180, 180, 190, 0.35); color: rgba(180, 180, 190, 0.6);
            border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;
        }
        .level-btn:hover { border-color: rgba(180, 180, 190, 0.6); color: rgba(220, 220, 230, 0.9); }
        .level-btn.active { border-color: rgba(34, 211, 153, 0.7); color: #34d399; box-shadow: 0 0 10px rgba(34, 211, 153, 0.3); }
        
        /* Panneau de notes */
        .notes-panel {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(18, 19, 26, 0.95); backdrop-filter: blur(10px);
            display: none; align-items: center; justify-content: center; z-index: 2000;
        }
        .notes-panel.active { display: flex; }
        .notes-content {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(180, 180, 190, 0.3);
            border-radius: 16px; padding: 24px; max-width: 90%; max-height: 80vh; overflow-y: auto;
            color: rgba(220, 220, 230, 0.9);
        }
        .notes-content h2 { color: #22d3ee; margin-bottom: 16px; font-size: 1.2rem; }
        .notes-content h3 { color: rgba(220, 220, 230, 0.8); margin: 16px 0 8px 0; font-size: 1rem; }
        .notes-content pre { 
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; 
            overflow-x: auto; font-family: monospace; font-size: 0.85rem; line-height: 1.6;
        }
        .notes-content p { line-height: 1.6; margin: 8px 0; color: rgba(180, 180, 190, 0.9); }
        .close-notes {
            margin-top: 16px; width: 100%; padding: 10px;
            background: transparent; border: 1px solid rgba(180, 180, 190, 0.35);
            color: rgba(180, 180, 190, 0.7); border-radius: 8px; cursor: pointer;
        }
        .close-notes:hover { border-color: #22d3ee; color: #22d3ee; }
        
        button {
            background: transparent; border: 1px solid rgba(180, 180, 190, 0.35); color: rgba(180, 180, 190, 0.7);
            padding: 8px 14px; border-radius: 8px; cursor: pointer; font-size: 0.75rem; letter-spacing: 0.05em; transition: all 0.2s;
        }
        button:hover { border-color: rgba(180, 180, 190, 0.6); color: rgba(220, 220, 230, 0.9); }
        
        /* Points flottants */
        .floating-points {
            position: fixed; pointer-events: none; font-size: 1.2rem; font-weight: bold;
            color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            animation: floatUp 1s ease-out forwards; z-index: 1000;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
        }
    </style>
</head>
<body>
    <div class="logo">
        <div class="logo-icon"><svg viewBox="0 0 36 36"><path d="M8 26L18 10L28 26"/></svg></div>
        <div class="logo-icon"><svg viewBox="0 0 36 36"><polygon points="10,10 26,18 10,26"/></svg></div>
        <div class="logo-icon"><svg viewBox="0 0 36 36"><path d="M8 26L18 10L28 26"/></svg></div>
        <div class="logo-icon"><svg viewBox="0 0 36 36"><line x1="10" y1="8" x2="10" y2="28"/><line x1="18" y1="8" x2="18" y2="28"/><line x1="26" y1="8" x2="26" y2="28"/></svg></div>
    </div>
    
    <div class="game-container" id="game-container">
        <!-- Layer menu concepteur -->
        <div class="settings-layer" id="settings-layer">
            <div style="display: flex; flex-direction: column; gap: 8px; padding: 10px; align-items: center; height: 100%; justify-content: space-evenly;">
                <!-- Ligne 1: Toggles -->
                <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: center;">
                    <button id="points-anim-toggle" class="points-toggle" title="Animation des points">‚ú®</button>
                    <button id="twin-toggle" class="points-toggle" title="Fusions Jumeaux">üëØ</button>
                    <button id="keep-state-toggle" class="points-toggle" title="Conserver √©tat au respawn">üîÑ</button>
                </div>
                
                <!-- Ligne 2: Compteurs fusion -->
                <div style="display: flex; gap: 6px; align-items: center; flex-wrap: wrap; justify-content: center;">
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <span class="stat-icon" style="color: #22d3ee; font-size: 0.7rem;">üíé</span>
                        <span class="score-value small" id="silver-count" style="font-size: 0.75rem;">0</span>
                    </div>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <span class="stat-icon" style="color: #ffd700; font-size: 0.7rem;">üèÜ</span>
                        <span class="score-value small" id="gold-count" style="font-size: 0.75rem;">0</span>
                    </div>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <span class="stat-icon" style="color: #34d399; font-size: 0.7rem;">üíö</span>
                        <span class="score-value small" id="emerald-count" style="font-size: 0.75rem;">0</span>
                    </div>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <span class="stat-icon" style="color: #c4b5fd; font-size: 0.7rem;">üåü</span>
                        <span class="score-value small" id="cosmic-count" style="font-size: 0.75rem;">0</span>
                    </div>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <span class="stat-icon" style="color: #ff8c00; font-size: 0.7rem;">‚òÄÔ∏è</span>
                        <span class="score-value small" id="supernovae-count" style="font-size: 0.75rem;">0</span>
                    </div>
                </div>
                
                <!-- Ligne 3: Niveaux -->
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="level-btn active" onclick="setLevel(1)">1</button>
                    <button class="level-btn" onclick="setLevel(2)">2</button>
                    <button class="level-btn" onclick="setLevel(3)">3</button>
                    <button class="level-btn" onclick="setLevel(4)">4</button>
                </div>
                
                <!-- Ligne 4: Actions -->
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button onclick="undo()" style="font-size: 0.7rem; padding: 6px 10px;">Undo</button>
                    <button onclick="toggleNotes()" style="font-size: 0.7rem; padding: 6px 10px;">Note</button>
                </div>
            </div>
        </div>
        
        <div class="grid" id="grid"></div>
    </div>
    
    <div class="score-bar">
        <div class="score-item">
            <span class="score-label">Score</span>
            <span class="score-value" id="score">0</span>
        </div>
        
        <div class="score-item">
            <span class="score-label combo-label">Combo</span>
            <span class="score-value combo" id="combo">√ó1</span>
        </div>
        
        <button id="undo-btn" onclick="undo()" style="padding: 4px 12px; font-size: 0.7rem;">Undo</button>
        
        <div class="score-item">
            <span class="score-label">Best</span>
            <span class="score-value" id="best">0</span>
        </div>
    </div>
    
    <!-- Panneau de notes -->
    <div class="notes-panel" id="notes-panel">
        <div class="notes-content">
            <h2>üìù Notes & Conventions</h2>
            
            <h3>Convention de num√©rotation de la grille :</h3>
            <p>Les dominos sont num√©rot√©s de gauche √† droite, de bas en haut :</p>
            <pre>
13  14  15    ‚Üê Ligne 5 (haut)
10  11  12    ‚Üê Ligne 4
7   8   9     ‚Üê Ligne 3
4   5   6     ‚Üê Ligne 2
1   2   3     ‚Üê Ligne 1 (bas)
            </pre>
            
            <h3>Contr√¥les :</h3>
            <p><strong>Tap moiti√© droite :</strong> rotation +90¬∞ (horaire)</p>
            <p><strong>Tap moiti√© gauche :</strong> rotation -90¬∞ (antihoraire)</p>
            <p><strong>Drag horizontal :</strong> d√©place toute la ligne (tapis roulant)</p>
            <p><em>Drag vertical d√©sactiv√©</em></p>
            
            <h3>Niveaux :</h3>
            <p>Chaque niveau (1, 2, 3, 4) g√©n√®re une grille unique avec une s√©quence pr√©d√©finie.</p>
            
            <button class="close-notes" onclick="toggleNotes()">Fermer</button>
        </div>
    </div>
    
    <script>
        const COLS = 3, ROWS = 5, TOTAL = 15;
        const STATE_ORDER = ['white', 'silver', 'gold', 'emerald', 'cosmic', 'supernovae'];
        const STATE_MULTIPLIER = { white: 1, silver: 2, gold: 3, emerald: 5, cosmic: 10, supernovae: 20 };
        const POINTS = { simple: 100, chain: 500, twin: 1000 };
        const FUSION_MOVE = 400, FUSION_FADE = 200, FUSION_APPEAR = 500, GRAVITY_DELAY = 150;
        const MAX_HISTORY = 20;
        
        let showPointsAnimation = true;
        let enableTwinFusion = false;
        let keepStateOnRespawn = false;
        
        const ICONS = {
            // Sigles niveau 1, 3, 4 (originaux)
            chevron: { f1: 'M20 32L45 12L70 32', f2: 'M20 12L45 32L70 12', t: 'path' },
            circle: { f1: '45,22,12', f2: '45,22,12', t: 'circle' },
            twoCircles: { f1: '30,22,8|60,22,8', f2: '30,22,8|60,22,8', t: 'circles' },
            line: { f1: '15,22,75,22', f2: '15,22,75,22', t: 'line' },
            threeLines: { f1: '25,10,25,34|45,10,45,34|65,10,65,34', f2: '25,10,25,34|45,10,45,34|65,10,65,34', t: 'lines' },
            twoPoints: { f1: '30,22,4|60,22,4', f2: '30,22,4|60,22,4', t: 'points' },
            square: { f1: '25,10,40,24,3', f2: '25,10,40,24,3', t: 'rect' },
            wave: { f1: 'M10 22Q28 6 45 22Q62 38 80 22', f2: 'M10 22Q28 6 45 22Q62 38 80 22', t: 'path' },
            
            // Nouveaux sigles niveau 2
            twoL: { f1: 'M15 10L15 22L27 22', f2: 'M75 10L75 22L63 22', t: 'path' },
            arc: { f1: 'M20 30Q45 8 70 30', f2: 'M20 14Q45 36 70 14', t: 'path' },
            twoSquares: { f1: '24,14,12,12,2|54,14,12,12,2', f2: '24,14,12,12,2|54,14,12,12,2', t: 'rects' },
            target: { f1: '45,22,12|45,22,4', f2: '45,22,12|45,22,4', t: 'target' },
            dumbbell: { f1: '30,22,5|60,22,5|30,22,60,22', f2: '30,22,5|60,22,5|30,22,60,22', t: 'dumbbell' },
            singleLine: { f1: '45,10,45,34', f2: '45,10,45,34', t: 'line' },
            singlePoint: { f1: '45,22,5', f2: '45,22,5', t: 'circle' },
            diamond: { f1: 'M45 10L60 22L45 34L30 22Z', f2: 'M45 10L60 22L45 34L30 22Z', t: 'path' },
            
            // Nouveaux sigles niveau 3 (difficile)
            cross: { f1: 'M45 8L45 36M29 22L61 22', f2: 'M45 8L45 36M29 22L61 22', t: 'path' },
            triangle: { f1: 'M45 10L65 34L25 34Z', f2: 'M45 34L65 10L25 10Z', t: 'path' },
            zigzag: { f1: 'M15 30L30 14L45 30L60 14L75 30', f2: 'M15 14L30 30L45 14L60 30L75 14', t: 'path' },
            brackets: { f1: 'M30 10L20 10L20 34L30 34', f2: 'M60 10L70 10L70 34L60 34', t: 'path' },
            threePoints: { f1: '30,22,4|45,22,4|60,22,4', f2: '30,22,4|45,22,4|60,22,4', t: 'points' },
            halfCircle: { f1: 'M30 30A15 15 0 0 1 60 30', f2: 'M30 14A15 15 0 0 0 60 14', t: 'path' },
            arrow: { f1: 'M20 22L70 22M55 12L70 22L55 32', f2: 'M70 22L20 22M35 12L20 22L35 32', t: 'path' },
            hexagon: { f1: 'M35 10L55 10L65 22L55 34L35 34L25 22Z', f2: 'M35 10L55 10L65 22L55 34L35 34L25 22Z', t: 'path' },
            
            // Nouveaux sigles niveau 4 (difficile, petits)
            miniDot: { f1: '45,22,3', f2: '45,22,3', t: 'circle' },
            twoDots: { f1: '38,22,3|52,22,3', f2: '38,22,3|52,22,3', t: 'points' },
            miniCross: { f1: 'M45 16L45 28M39 22L51 22', f2: 'M45 16L45 28M39 22L51 22', t: 'path' },
            miniSquare: { f1: '38,15,14,14,2', f2: '38,15,14,14,2', t: 'rect' },
            miniTriangle: { f1: 'M45 14L54 30L36 30Z', f2: 'M45 30L54 14L36 14Z', t: 'path' },
            slash: { f1: 'M35 30L55 14', f2: 'M35 14L55 30', t: 'path' },
            miniV: { f1: 'M35 14L45 28L55 14', f2: 'M35 30L45 16L55 30', t: 'path' },
            fourDots: { f1: '38,16,2|52,16,2|38,28,2|52,28,2', f2: '38,16,2|52,16,2|38,28,2|52,28,2', t: 'points' }
        };
        
        // Sets d'ic√¥nes par niveau
        const LEVEL_ICON_SETS = {
            1: ['chevron', 'circle', 'twoCircles', 'line', 'threeLines', 'twoPoints', 'square', 'wave'],
            2: ['twoL', 'arc', 'twoSquares', 'target', 'dumbbell', 'singleLine', 'singlePoint', 'diamond'],
            3: ['cross', 'triangle', 'zigzag', 'brackets', 'threePoints', 'halfCircle', 'arrow', 'hexagon'],
            4: ['miniDot', 'twoDots', 'miniCross', 'miniSquare', 'miniTriangle', 'slash', 'miniV', 'fourDots']
        };
        
        function getIconKeysForLevel(level) {
            return LEVEL_ICON_SETS[level] || LEVEL_ICON_SETS[1];
        }
        
        let dominos = [], grid = document.getElementById('grid');
        let gameContainer = document.getElementById('game-container');
        let isAnimating = false;
        let history = [], scoreHistory = [];
        let score = 0, bestScore = 0, comboCount = 0, lastFusionTime = 0;
        let currentLevel = 1;
        let fusionCounts = { silver: 0, gold: 0, emerald: 0, cosmic: 0, supernovae: 0 };
        let dropSettings = { silver: 0, gold: 1, emerald: 2, cosmic: 0 };
        let dominoSequenceIndex = 1;
        
        // Variables pour le syst√®me de drag (tapis roulant)
        let isDragging = false;
        let dragAxis = null; // 'horizontal' ou 'vertical'
        let dragRow = -1, dragCol = -1;
        let dragStartX = 0, dragStartY = 0;
        let dragStartTime = 0;
        let dragOffset = 0;
        let clickedDominoIdx = null;
        let clickLocalX = 0;
        let initialPositions = [];
        let ghostElements = [];
        let dominoElements = [];
        let lastMovedIndices = [];
        
        // Dimensions calcul√©es
        let CELL_SIZE = 0, GAP_SIZE = 0, CELL_TOTAL = 0;
        let GRID_WIDTH = 0, GRID_HEIGHT = 0;
        
        // Configurations des 4 niveaux
        const LEVEL_SEEDS = { 1: 12345, 2: 67890, 3: 77777, 4: 99991 };
        
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 1103515245 + 12345) & 0x7fffffff;
                return state / 0x7fffffff;
            };
        }
        
        function updateDimensions() {
            // Calculer depuis le CSS
            const gridStyle = getComputedStyle(grid);
            const cellValue = gridStyle.getPropertyValue('--cell').trim();
            const gapValue = gridStyle.getPropertyValue('--gap').trim();
            
            // Parser la valeur de cell (min(100px, 31vw) pour 3 colonnes)
            CELL_SIZE = Math.min(100, window.innerWidth * 0.31);
            GAP_SIZE = 0;
            CELL_TOTAL = CELL_SIZE + GAP_SIZE;
            GRID_WIDTH = COLS * CELL_TOTAL;
            GRID_HEIGHT = ROWS * CELL_TOTAL;
        }
        
        function getDominoFromSequence(position) {
            const rng = seededRandom(LEVEL_SEEDS[currentLevel]);
            const iconKeys = getIconKeysForLevel(currentLevel);
            for (let i = 0; i < position; i++) { rng(); rng(); }
            const x = (position - 1) % COLS;
            const y = Math.floor((position - 1) / COLS);
            return { 
                face1: iconKeys[Math.floor(rng() * iconKeys.length)], 
                face2: iconKeys[Math.floor(rng() * iconKeys.length)], 
                rotation: ((x + y) % 2 === 0) ? 0 : 90, 
                state: 'white' 
            };
        }
        
        function dropNewDominos(count) {
            if (count === 0) return;
            isAnimating = true;
            let droppedCount = 0;
            
            function dropOne() {
                if (droppedCount >= count) {
                    isAnimating = false;
                    applyGravity();
                    return;
                }
                let targetCol = -1;
                // Chercher une colonne avec case vide en haut (y=0)
                for (let c = 0; c < COLS; c++) {
                    const topIdx = c; // y=0
                    if (!dominos[topIdx]) { targetCol = c; break; }
                }
                if (targetCol === -1) { isAnimating = false; return; }
                const topIdx = targetCol;
                const newDomino = getDominoFromSequence(dominoSequenceIndex);
                dominoSequenceIndex = (dominoSequenceIndex % 24) + 1;
                dominos[topIdx] = newDomino;
                render();
                droppedCount++;
                setTimeout(dropOne, 250);
            }
            dropOne();
        }

        function renderIcon(icon, isFace2) {
            const d = ICONS[icon], data = isFace2 ? d.f2 : d.f1;
            if (d.t === 'path') return `<path class="icon" d="${data}"/>`;
            if (d.t === 'circle') { const [cx,cy,r] = data.split(','); return `<circle class="icon" cx="${cx}" cy="${cy}" r="${r}"/>`; }
            if (d.t === 'line') { const [x1,y1,x2,y2] = data.split(','); return `<line class="icon" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`; }
            if (d.t === 'rect') { const [x,y,w,h,rx] = data.split(','); return `<rect class="icon" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`; }
            if (d.t === 'rects') {
                return data.split('|').map(p => {
                    const [x,y,w,h,rx] = p.split(',');
                    return `<rect class="icon" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`;
                }).join('');
            }
            if (d.t === 'target') {
                const parts = data.split('|');
                const [cx1,cy1,r1] = parts[0].split(',');
                const [cx2,cy2,r2] = parts[1].split(',');
                return `<circle class="icon" cx="${cx1}" cy="${cy1}" r="${r1}"/><circle class="point" cx="${cx2}" cy="${cy2}" r="${r2}"/>`;
            }
            if (d.t === 'dumbbell') {
                const parts = data.split('|');
                const [cx1,cy1,r1] = parts[0].split(',');
                const [cx2,cy2,r2] = parts[1].split(',');
                const [x1,y1,x2,y2] = parts[2].split(',');
                return `<circle class="point" cx="${cx1}" cy="${cy1}" r="${r1}"/><circle class="point" cx="${cx2}" cy="${cy2}" r="${r2}"/><line class="icon" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`;
            }
            return data.split('|').map(p => {
                const v = p.split(',');
                return (d.t === 'circles' || d.t === 'points') 
                    ? `<circle class="${d.t === 'points' ? 'point' : 'icon'}" cx="${v[0]}" cy="${v[1]}" r="${v[2]}"/>`
                    : `<line class="icon" x1="${v[0]}" y1="${v[1]}" x2="${v[2]}" y2="${v[3]}"/>`;
            }).join('');
        }

        function renderDomino(d) {
            // Rotation interne via CSS transform (pas attribut SVG)
            // overflow:hidden du .square masque ce qui d√©passe
            const rot = d.rotation || 0;
            return `<svg viewBox="0 0 90 90">
                <g class="domino-content" style="transform: rotate(${rot}deg)">
                    <line class="separator" x1="0" y1="45" x2="90" y2="45"/>
                    <g>${renderIcon(d.face1, false)}</g>
                    <g transform="translate(0,45)">${renderIcon(d.face2, true)}</g>
                </g>
            </svg>`;
        }

        function render() {
            grid.innerHTML = '';
            dominoElements = [];
            
            // Calculer dimensions - synchronis√© avec CSS (31vw pour 3 colonnes)
            CELL_SIZE = Math.min(100, window.innerWidth * 0.31);
            GAP_SIZE = 0;
            CELL_TOTAL = CELL_SIZE + GAP_SIZE;
            
            for (let i = 0; i < TOTAL; i++) {
                const col = i % COLS;
                const row = Math.floor(i / COLS);
                
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.style.left = (col * CELL_TOTAL) + 'px';
                cell.style.top = (row * CELL_TOTAL) + 'px';
                
                const div = document.createElement('div');
                div.dataset.index = i;
                
                if (dominos[i]) {
                    const displayState = dominos[i].state1 || dominos[i].state;
                    div.className = `square ${displayState}`;
                    div.innerHTML = renderDomino(dominos[i]);
                    // Rotation interne au SVG, pas sur le conteneur
                } else {
                    div.className = 'square empty';
                }
                
                cell.appendChild(div);
                grid.appendChild(cell);
                dominoElements.push(div);
            }
        }

        function getPos(i) { return { x: i % COLS, y: Math.floor(i / COLS) }; }
        function getIndex(x, y) { return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? -1 : y * COLS + x; }

        function getExposedFace(domino, dir) {
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 0: { top: 'face1', bottom: 'face2' }, 90: { left: 'face2', right: 'face1' }, 180: { top: 'face2', bottom: 'face1' }, 270: { left: 'face1', right: 'face2' } };
            const face = map[r]?.[dir]; return face ? domino[face] : null;
        }

        function getExposedState(domino, dir) {
            if (domino.state1 !== undefined) {
                const r = ((domino.rotation % 360) + 360) % 360;
                const map = { 
                    0: { top: 'state1', bottom: 'state2' }, 
                    90: { left: 'state2', right: 'state1' }, 
                    180: { top: 'state2', bottom: 'state1' }, 
                    270: { left: 'state1', right: 'state2' } 
                };
                const stateKey = map[r]?.[dir];
                return stateKey ? domino[stateKey] : domino.state1;
            }
            return domino.state;
        }

        function getRemainingFace(domino, excDir) {
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 0: { top: 'face2', bottom: 'face1' }, 90: { right: 'face2', left: 'face1' }, 180: { top: 'face1', bottom: 'face2' }, 270: { right: 'face1', left: 'face2' } };
            const face = map[r]?.[excDir]; return face ? domino[face] : null;
        }

        function areTwins(d1, d2) {
            if (!d1 || !d2) return false;
            const s1_1 = d1.state1 || d1.state;
            const s1_2 = d1.state2 || d1.state;
            const s2_1 = d2.state1 || d2.state;
            const s2_2 = d2.state2 || d2.state;
            if (s1_1 !== s1_2 || s2_1 !== s2_2 || s1_1 !== s2_1) return false;
            const r1 = ((d1.rotation % 360) + 360) % 360;
            const r2 = ((d2.rotation % 360) + 360) % 360;
            if (r1 === r2 && d1.face1 === d2.face1 && d1.face2 === d2.face2) return true;
            if (Math.abs(r1 - r2) === 180 && d1.face1 === d2.face2 && d1.face2 === d2.face1) return true;
            const diff = Math.abs(r1 - r2);
            if (diff === 90 || diff === 270) {
                if (d1.face1 === d2.face2 && d1.face2 === d2.face1) return true;
            }
            return false;
        }

        // ============================================
        // SYST√àME DE GHOSTS POUR WRAP-AROUND
        // ============================================
        
        function createGhosts(axis, rowOrCol) {
            clearGhosts();
            
            if (axis === 'horizontal') {
                for (let c = 0; c < COLS; c++) {
                    const idx = rowOrCol * COLS + c;
                    const domino = dominos[idx];
                    if (!domino) continue;
                    
                    const displayState = domino.state1 || domino.state;
                    
                    // Ghost gauche
                    const ghostLeft = document.createElement('div');
                    ghostLeft.className = `square ghost ${displayState}`;
                    ghostLeft.innerHTML = renderDomino(domino);
                    ghostLeft.style.position = 'absolute';
                    ghostLeft.style.width = CELL_SIZE + 'px';
                    ghostLeft.style.height = CELL_SIZE + 'px';
                    ghostLeft.style.left = (c * CELL_TOTAL - COLS * CELL_TOTAL) + 'px';
                    ghostLeft.style.top = (rowOrCol * CELL_TOTAL) + 'px';
                    ghostLeft.style.transform = `rotate(${domino.rotation}deg)`;
                    grid.appendChild(ghostLeft);
                    ghostElements.push({ el: ghostLeft, baseX: c * CELL_TOTAL - COLS * CELL_TOTAL, idx });
                    
                    // Ghost droite
                    const ghostRight = document.createElement('div');
                    ghostRight.className = `square ghost ${displayState}`;
                    ghostRight.innerHTML = renderDomino(domino);
                    ghostRight.style.position = 'absolute';
                    ghostRight.style.width = CELL_SIZE + 'px';
                    ghostRight.style.height = CELL_SIZE + 'px';
                    ghostRight.style.left = (c * CELL_TOTAL + COLS * CELL_TOTAL) + 'px';
                    ghostRight.style.top = (rowOrCol * CELL_TOTAL) + 'px';
                    ghostRight.style.transform = `rotate(${domino.rotation}deg)`;
                    grid.appendChild(ghostRight);
                    ghostElements.push({ el: ghostRight, baseX: c * CELL_TOTAL + COLS * CELL_TOTAL, idx });
                }
            } else {
                for (let r = 0; r < ROWS; r++) {
                    const idx = r * COLS + rowOrCol;
                    const domino = dominos[idx];
                    if (!domino) continue;
                    
                    const displayState = domino.state1 || domino.state;
                    
                    // Ghost haut
                    const ghostTop = document.createElement('div');
                    ghostTop.className = `square ghost ${displayState}`;
                    ghostTop.innerHTML = renderDomino(domino);
                    ghostTop.style.position = 'absolute';
                    ghostTop.style.width = CELL_SIZE + 'px';
                    ghostTop.style.height = CELL_SIZE + 'px';
                    ghostTop.style.left = (rowOrCol * CELL_TOTAL) + 'px';
                    ghostTop.style.top = (r * CELL_TOTAL - ROWS * CELL_TOTAL) + 'px';
                    ghostTop.style.transform = `rotate(${domino.rotation}deg)`;
                    grid.appendChild(ghostTop);
                    ghostElements.push({ el: ghostTop, baseY: r * CELL_TOTAL - ROWS * CELL_TOTAL, idx });
                    
                    // Ghost bas
                    const ghostBottom = document.createElement('div');
                    ghostBottom.className = `square ghost ${displayState}`;
                    ghostBottom.innerHTML = renderDomino(domino);
                    ghostBottom.style.position = 'absolute';
                    ghostBottom.style.width = CELL_SIZE + 'px';
                    ghostBottom.style.height = CELL_SIZE + 'px';
                    ghostBottom.style.left = (rowOrCol * CELL_TOTAL) + 'px';
                    ghostBottom.style.top = (r * CELL_TOTAL + ROWS * CELL_TOTAL) + 'px';
                    ghostBottom.style.transform = `rotate(${domino.rotation}deg)`;
                    grid.appendChild(ghostBottom);
                    ghostElements.push({ el: ghostBottom, baseY: r * CELL_TOTAL + ROWS * CELL_TOTAL, idx });
                }
            }
        }
        
        function clearGhosts() {
            ghostElements.forEach(g => g.el.remove());
            ghostElements = [];
        }

        // ============================================
        // GESTION DU DRAG (TAPIS ROULANT)
        // ============================================
        
        function startDrag(e) {
            if (isAnimating) return;
            
            const el = e.target.closest('.square');
            if (!el || el.classList.contains('ghost') || el.classList.contains('empty')) return;
            
            e.preventDefault();
            
            const idx = parseInt(el.dataset.index);
            const col = idx % COLS;
            const row = Math.floor(idx / COLS);
            
            isDragging = true;
            dragAxis = null;
            dragRow = row;
            dragCol = col;
            dragOffset = 0;
            clickedDominoIdx = idx;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragStartX = clientX;
            dragStartY = clientY;
            dragStartTime = Date.now();
            
            // Position du clic relative au domino pour tap bidirectionnel
            const rect = el.getBoundingClientRect();
            clickLocalX = clientX - rect.left;
            
            initialPositions = [];
        }
        
        function moveDrag(e) {
            if (!isDragging || isAnimating) return;
            e.preventDefault();
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const deltaX = clientX - dragStartX;
            const deltaY = clientY - dragStartY;
            
            // D√©terminer l'axe au premier mouvement significatif
            // DRAG VERTICAL GEL√â - seul l'horizontal est actif
            if (dragAxis === null) {
                const threshold = 8;
                if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                    // Forcer horizontal uniquement (vertical gel√©)
                    if (Math.abs(deltaX) > threshold) {
                        dragAxis = 'horizontal';
                        
                        saveState();
                        
                        for (let c = 0; c < COLS; c++) {
                            const idx = dragRow * COLS + c;
                            initialPositions.push({ idx, baseX: c * CELL_TOTAL });
                        }
                        createGhosts('horizontal', dragRow);
                    } else {
                        // Vertical d√©tect√© mais gel√© ‚Üí on ignore
                        return;
                    }
                }
            }
            
            if (dragAxis === null) return;
            
            // D√©placer les dominos et les ghosts (horizontal uniquement)
            if (dragAxis === 'horizontal') {
                dragOffset = deltaX;
                
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (cell) {
                        const newX = item.baseX + dragOffset;
                        cell.style.transition = 'none';
                        cell.style.left = newX + 'px';
                    }
                }
                
                for (const ghost of ghostElements) {
                    const newX = ghost.baseX + dragOffset;
                    ghost.el.style.transition = 'none';
                    ghost.el.style.left = newX + 'px';
                }
            }
        }
        
        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            
            const elapsed = Date.now() - dragStartTime;
            const distance = Math.abs(dragOffset);
            
            // Si c'est un tap ‚Üí rotation selon la position (moiti√© gauche/droite)
            if (distance < 8 && elapsed < 250 && clickedDominoIdx !== null) {
                const clickedRight = clickLocalX > (CELL_SIZE / 2);
                rotateDomino(clickedDominoIdx, clickedRight);
                clearGhosts();
                clickedDominoIdx = null;
                dragAxis = null;
                initialPositions = [];
                return;
            }
            
            clickedDominoIdx = null;
            
            if (dragAxis === null) {
                clearGhosts();
                return;
            }
            
            // Calculer le nombre de crans
            let steps = Math.round(dragOffset / CELL_TOTAL);
            
            // Horizontal uniquement (vertical gel√©)
            if (dragAxis === 'horizontal') {
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (!cell) continue;
                    
                    let currentX = item.baseX + dragOffset;
                    const originalCol = Math.round(item.baseX / CELL_TOTAL);
                    const newCol = ((originalCol + steps) % COLS + COLS) % COLS;
                    const targetX = newCol * CELL_TOTAL;
                    
                    while (currentX - targetX > COLS * CELL_TOTAL / 2) currentX -= COLS * CELL_TOTAL;
                    while (targetX - currentX > COLS * CELL_TOTAL / 2) currentX += COLS * CELL_TOTAL;
                    
                    cell.style.transition = 'none';
                    cell.style.left = currentX + 'px';
                }
                
                grid.offsetHeight;
                
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (!cell) continue;
                    
                    const originalCol = Math.round(item.baseX / CELL_TOTAL);
                    const newCol = ((originalCol + steps) % COLS + COLS) % COLS;
                    const targetX = newCol * CELL_TOTAL;
                    
                    cell.style.transition = 'left 0.15s ease-out';
                    cell.style.left = targetX + 'px';
                }
                
                const row = dragRow;
                const newRowDominos = [];
                for (let c = 0; c < COLS; c++) {
                    const sourceCol = ((c - steps) % COLS + COLS) % COLS;
                    newRowDominos[c] = dominos[row * COLS + sourceCol];
                }
                for (let c = 0; c < COLS; c++) {
                    dominos[row * COLS + c] = newRowDominos[c];
                }
                
                lastMovedIndices = [];
                for (let c = 0; c < COLS; c++) {
                    lastMovedIndices.push(row * COLS + c);
                }
            }
            
            clearGhosts();
            
            setTimeout(() => {
                render();
                checkFusions();
            }, 160);
            
            dragAxis = null;
            initialPositions = [];
        }

        // ============================================
        // ROTATION INDIVIDUELLE (TAP BIDIRECTIONNEL)
        // ============================================
        
        function rotateDomino(idx, clockwise = true) {
            const domino = dominos[idx];
            if (!domino) return;
            
            saveState();
            
            const oldRotation = domino.rotation || 0;
            domino.rotation = oldRotation + (clockwise ? 90 : -90);
            lastMovedIndices = [idx];
            
            const el = dominoElements[idx];
            if (el) {
                // Animation smooth de rotation interne via CSS transform
                const contentGroup = el.querySelector('.domino-content');
                if (contentGroup) {
                    // Utiliser CSS transform au lieu de l'attribut SVG transform
                    contentGroup.style.transform = `rotate(${domino.rotation}deg)`;
                }
                
                setTimeout(() => {
                    checkFusions();
                }, 250);
            }
        }

        // ============================================
        // SYST√àME DE FUSION (IDENTIQUE √Ä LAYER V2)
        // ============================================

        function addScore(basePoints, fusionType, states) {
            const now = Date.now();
            let stateMultiplier = 1;
            states.forEach(s => { stateMultiplier = Math.max(stateMultiplier, STATE_MULTIPLIER[s] || 1); });
            if (now - lastFusionTime < 2000 && lastFusionTime > 0) comboCount++;
            else comboCount = 1;
            lastFusionTime = now;
            const comboMultiplier = 1 + (comboCount - 1) * 0.5;
            const points = Math.round(basePoints * stateMultiplier * comboMultiplier);
            score += points;
            if (score > bestScore) bestScore = score;
            updateScoreDisplay(points);
            return points;
        }

        function updateScoreDisplay(pointsAdded) {
            const scoreEl = document.getElementById('score');
            const comboEl = document.getElementById('combo');
            const bestEl = document.getElementById('best');
            scoreEl.textContent = score.toLocaleString();
            scoreEl.classList.remove('highlight'); void scoreEl.offsetWidth; scoreEl.classList.add('highlight');
            comboEl.textContent = comboCount > 1 ? `√ó${(1 + (comboCount - 1) * 0.5).toFixed(1)}` : '√ó1';
            comboEl.style.opacity = comboCount > 1 ? '1' : '0.5';
            bestEl.textContent = bestScore.toLocaleString();
        }

        function showFloatingPoints(points, x, y) {
            if (!showPointsAnimation) return;
            const el = document.createElement('div');
            el.className = 'floating-points';
            el.textContent = `+${points.toLocaleString()}`;
            el.style.left = `${x}px`; el.style.top = `${y}px`;
            el.style.color = 'rgba(255, 255, 255, 0.9)';
            el.style.textShadow = '0 0 8px rgba(255, 255, 255, 0.6)';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
        
        function showVictory() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(10px);
                display: flex; flex-direction: column; align-items: center; justify-content: center;
                z-index: 10000; animation: fadeIn 0.5s ease-out;
            `;
            
            const title = document.createElement('div');
            title.textContent = 'üèÜ VICTOIRE ! üèÜ';
            title.style.cssText = `
                font-size: 3rem; font-weight: 700; color: #ffd700;
                text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
                margin-bottom: 20px; animation: pulse 1s ease-in-out infinite;
            `;
            
            const scoreText = document.createElement('div');
            scoreText.textContent = `Score final : ${score.toLocaleString()}`;
            scoreText.style.cssText = `font-size: 1.5rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 30px;`;
            
            const btn = document.createElement('button');
            btn.textContent = 'Rejouer';
            btn.style.cssText = `
                padding: 15px 40px; font-size: 1.2rem; font-weight: 600;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border: none; border-radius: 12px; color: white;
                cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            `;
            btn.onclick = () => { overlay.remove(); resetGame(); };
            
            overlay.appendChild(title);
            overlay.appendChild(scoreText);
            overlay.appendChild(btn);
            document.body.appendChild(overlay);
        }

        function checkFusions(skipGravity = false) {
            if (isAnimating) return;
            
            // Twin fusion (priorit√© haute) - seulement si activ√©es
            if (enableTwinFusion) {
                for (let i = 0; i < TOTAL; i++) {
                    if (!dominos[i]) continue;
                    const { x, y } = getPos(i);
                    const iR = getIndex(x+1, y);
                    if (iR !== -1 && areTwins(dominos[i], dominos[iR])) { performTwinFusion(i, iR, 'h'); return; }
                    const iB = getIndex(x, y+1);
                    if (iB !== -1 && areTwins(dominos[i], dominos[iB])) { performTwinFusion(i, iB, 'v'); return; }
                }
            }
            
            // Chain fusion
            for (let i = 0; i < TOTAL; i++) {
                if (!dominos[i]) continue;
                const { x, y } = getPos(i);
                if (x > 0 && x < COLS-1) {
                    const iL = getIndex(x-1,y), iR = getIndex(x+1,y);
                    if (iL !== -1 && iR !== -1 && dominos[iL] && dominos[iR]) {
                        const fLR = getExposedFace(dominos[iL], 'right'), fCL = getExposedFace(dominos[i], 'left');
                        const fCR = getExposedFace(dominos[i], 'right'), fRL = getExposedFace(dominos[iR], 'left');
                        const sLR = getExposedState(dominos[iL], 'right'), sCL = getExposedState(dominos[i], 'left');
                        const sCR = getExposedState(dominos[i], 'right'), sRL = getExposedState(dominos[iR], 'left');
                        if (fLR && fCL && fLR === fCL && sLR === sCL && fCR && fRL && fCR === fRL && sCR === sRL) { 
                            performChainFusion(iL, i, iR, 'h'); return; 
                        }
                    }
                }
                if (y > 0 && y < ROWS-1) {
                    const iT = getIndex(x,y-1), iB = getIndex(x,y+1);
                    if (iT !== -1 && iB !== -1 && dominos[iT] && dominos[iB]) {
                        const fTB = getExposedFace(dominos[iT], 'bottom'), fCT = getExposedFace(dominos[i], 'top');
                        const fCB = getExposedFace(dominos[i], 'bottom'), fBT = getExposedFace(dominos[iB], 'top');
                        const sTB = getExposedState(dominos[iT], 'bottom'), sCT = getExposedState(dominos[i], 'top');
                        const sCB = getExposedState(dominos[i], 'bottom'), sBT = getExposedState(dominos[iB], 'top');
                        if (fTB && fCT && fTB === fCT && sTB === sCT && fCB && fBT && fCB === fBT && sCB === sBT) { 
                            performChainFusion(iT, i, iB, 'v'); return; 
                        }
                    }
                }
            }
            
            // Simple fusion
            for (let i = 0; i < TOTAL; i++) {
                if (!dominos[i]) continue;
                const { x, y } = getPos(i);
                const iR = getIndex(x+1, y);
                if (iR !== -1 && dominos[iR]) {
                    const fL = getExposedFace(dominos[i], 'right'), fR = getExposedFace(dominos[iR], 'left');
                    const sL = getExposedState(dominos[i], 'right'), sR = getExposedState(dominos[iR], 'left');
                    if (fL && fR && fL === fR && sL === sR) { performSimpleFusion(i, iR, 'h'); return; }
                }
                const iB = getIndex(x, y+1);
                if (iB !== -1 && dominos[iB]) {
                    const fT = getExposedFace(dominos[i], 'bottom'), fB = getExposedFace(dominos[iB], 'top');
                    const sT = getExposedState(dominos[i], 'bottom'), sB = getExposedState(dominos[iB], 'top');
                    if (fT && fB && fT === fB && sT === sB) { performSimpleFusion(i, iB, 'v'); return; }
                }
            }
            
            lastMovedIndices = [];
            
            if (!skipGravity) {
                applyGravity();
            }
        }

        function performSimpleFusion(idx1, idx2, dir) {
            isAnimating = true;
            const d1 = dominos[idx1], d2 = dominos[idx2];
            const el1 = dominoElements[idx1], el2 = dominoElements[idx2];
            if (!el1 || !el2) { isAnimating = false; return; }
            
            // Faces qui fusionnent (disparaissent)
            const fusionFace1 = getExposedFace(d1, dir === 'h' ? 'right' : 'bottom') || d1.face1;
            const fusionFace2 = getExposedFace(d2, dir === 'h' ? 'left' : 'top') || d2.face1;
            
            // Faces partenaires (celles qui restent)
            const nf1 = getRemainingFace(d1, dir === 'h' ? 'right' : 'bottom') || d1.face2;
            const nf2 = getRemainingFace(d2, dir === 'h' ? 'left' : 'top') || d2.face2;
            
            // √âtat actuel des faces qui fusionnent
            const currentState = getExposedState(d1, dir === 'h' ? 'right' : 'bottom');
            const currentStateIdx = STATE_ORDER.indexOf(currentState);
            
            // Fusion simple : +1 √©tat pour les partenaires
            const nextStateIdx = Math.min(currentStateIdx + 1, STATE_ORDER.length - 1);
            const partnerState = STATE_ORDER[nextStateIdx];
            
            // Le domino jumeau (les 2 faces qui ont fusionn√©) reviendra selon option
            const twinState = keepStateOnRespawn ? currentState : 'white';
            const twinDomino = {
                face1: fusionFace1,
                face2: fusionFace2,
                rotation: 0,
                state: twinState,
                state1: twinState,
                state2: twinState
            };
            
            // Comptage des fusions par √©tat atteint
            if (partnerState !== 'white' && fusionCounts[partnerState] !== undefined) {
                fusionCounts[partnerState]++;
                document.getElementById(partnerState + '-count').textContent = fusionCounts[partnerState];
            }
            
            // Points
            let basePoints = POINTS.simple;
            if (currentState !== 'white') {
                const stateBonus = { 'silver': 1000, 'gold': 3000, 'emerald': 5000, 'cosmic': 10000, 'supernovae': 25000 };
                basePoints = stateBonus[currentState] || POINTS.simple;
            }
            
            const points = addScore(basePoints, 'simple', [d1.state, d2.state]);
            const rect = el1.getBoundingClientRect();
            showFloatingPoints(points, rect.left + rect.width/2, rect.top);
            
            el1.classList.add('fusing'); el2.classList.add('fusing');
            
            setTimeout(() => {
                // Le domino r√©sultant avec les faces partenaires
                dominos[idx1] = { 
                    face1: nf1, 
                    face2: nf2, 
                    rotation: dir === 'h' ? 90 : 0, 
                    state: 'white',
                    state1: partnerState,
                    state2: partnerState
                };
                dominos[idx2] = null; 
                render();
                setTimeout(() => { 
                    isAnimating = false;
                    // Gravit√© puis respawn du domino jumeau
                    applyGravityThenRespawn([twinDomino]);
                }, FUSION_APPEAR);
            }, FUSION_MOVE);
        }

        function performChainFusion(idx1, idx2, idx3, dir) {
            isAnimating = true;
            const d1 = dominos[idx1], d2 = dominos[idx2], d3 = dominos[idx3];
            const el1 = dominoElements[idx1], el2 = dominoElements[idx2], el3 = dominoElements[idx3];
            if (!el1 || !el2 || !el3) { isAnimating = false; return; }
            
            // Faces qui fusionnent (4 faces au total, 2 paires)
            const fusionFace1 = getExposedFace(d1, dir === 'h' ? 'right' : 'bottom') || d1.face1;
            const fusionFace2 = getExposedFace(d3, dir === 'h' ? 'left' : 'top') || d3.face1;
            
            // Faces partenaires (les faces externes qui restent)
            const nf1 = getRemainingFace(d1, dir === 'h' ? 'right' : 'bottom') || d1.face2;
            const nf2 = getRemainingFace(d3, dir === 'h' ? 'left' : 'top') || d3.face2;
            
            // √âtat actuel
            const currentState = getExposedState(d1, dir === 'h' ? 'right' : 'bottom');
            const currentStateIdx = STATE_ORDER.indexOf(currentState);
            
            // Fusion chain : +2 √©tats pour les partenaires
            const nextStateIdx = Math.min(currentStateIdx + 2, STATE_ORDER.length - 1);
            const partnerState = STATE_ORDER[nextStateIdx];
            
            // 2 dominos jumeaux (les 2 paires de faces qui ont fusionn√©) selon option
            const twinState = keepStateOnRespawn ? currentState : 'white';
            const twinDominos = [
                { face1: fusionFace1, face2: fusionFace1, rotation: 0, state: twinState, state1: twinState, state2: twinState },
                { face1: fusionFace2, face2: fusionFace2, rotation: 0, state: twinState, state1: twinState, state2: twinState }
            ];
            
            // Comptage des fusions
            if (partnerState !== 'white' && fusionCounts[partnerState] !== undefined) {
                fusionCounts[partnerState]++;
                document.getElementById(partnerState + '-count').textContent = fusionCounts[partnerState];
            }
            
            // Points
            let basePoints = POINTS.chain;
            if (currentState !== 'white') {
                const stateBonus = { 'silver': 2000, 'gold': 5000, 'emerald': 10000, 'cosmic': 20000, 'supernovae': 50000 };
                basePoints = stateBonus[currentState] || POINTS.chain;
            }
            
            const points = addScore(basePoints, 'chain', [d1.state, d2.state, d3.state]);
            const rect = el2.getBoundingClientRect();
            showFloatingPoints(points, rect.left + rect.width/2, rect.top);
            
            el1.classList.add('fusing'); el2.classList.add('fusing'); el3.classList.add('fusing');
            
            setTimeout(() => {
                // Le domino r√©sultant avec les faces partenaires
                dominos[idx2] = { 
                    face1: nf1, 
                    face2: nf2, 
                    rotation: d2.rotation, 
                    state: 'white',
                    state1: partnerState,
                    state2: partnerState
                };
                dominos[idx1] = null; 
                dominos[idx3] = null; 
                render();
                setTimeout(() => { 
                    isAnimating = false;
                    // Gravit√© puis respawn des 2 dominos jumeaux
                    applyGravityThenRespawn(twinDominos);
                }, FUSION_APPEAR);
            }, FUSION_MOVE);
        }

        function performTwinFusion(idx1, idx2, dir) {
            isAnimating = true;
            const d1 = dominos[idx1], d2 = dominos[idx2];
            
            const currentState = d1.state1 || d1.state;
            const currentIdx = STATE_ORDER.indexOf(currentState);
            const nextState = STATE_ORDER[Math.min(currentIdx + 2, STATE_ORDER.length - 1)];
            
            const states = [d1.state, d2.state];
            const points = addScore(POINTS.twin, 'twin', states);
            
            const el1 = dominoElements[idx1];
            if (el1) {
                const rect = el1.getBoundingClientRect();
                showFloatingPoints(points, rect.left + rect.width/2, rect.top);
            }
            
            if (STATE_ORDER.indexOf(nextState) >= STATE_ORDER.indexOf('silver')) fusionCounts.silver++;
            if (STATE_ORDER.indexOf(nextState) >= STATE_ORDER.indexOf('gold')) fusionCounts.gold++;
            if (STATE_ORDER.indexOf(nextState) >= STATE_ORDER.indexOf('emerald')) fusionCounts.emerald++;
            if (STATE_ORDER.indexOf(nextState) >= STATE_ORDER.indexOf('cosmic')) fusionCounts.cosmic++;
            if (STATE_ORDER.indexOf(nextState) >= STATE_ORDER.indexOf('supernovae')) fusionCounts.supernovae++;
            
            document.getElementById('silver-count').textContent = fusionCounts.silver;
            document.getElementById('gold-count').textContent = fusionCounts.gold;
            document.getElementById('emerald-count').textContent = fusionCounts.emerald;
            document.getElementById('cosmic-count').textContent = fusionCounts.cosmic;
            document.getElementById('supernovae-count').textContent = fusionCounts.supernovae;
            
            const twinDominos = [
                { ...d1, state: nextState, state1: nextState, state2: nextState },
                { ...d2, state: nextState, state1: nextState, state2: nextState }
            ];
            
            setTimeout(() => {
                dominos[idx1] = null;
                dominos[idx2] = null;
                render();
                isAnimating = false;
                applyGravityThenRespawn(twinDominos);
            }, FUSION_MOVE);
        }

        function applyGravity(callback) {
            let moved = false;
            // Parcourir de bas en haut (y d√©croissant) pour faire tomber vers le bas (y croissant)
            for (let x = 0; x < COLS; x++) {
                for (let y = ROWS - 2; y >= 0; y--) {
                    const idx = getIndex(x, y);
                    if (dominos[idx]) {
                        let targetY = y;
                        // Chercher la position la plus basse disponible
                        while (targetY < ROWS - 1 && !dominos[getIndex(x, targetY + 1)]) targetY++;
                        if (targetY !== y) {
                            dominos[getIndex(x, targetY)] = dominos[idx];
                            dominos[idx] = null;
                            moved = true;
                        }
                    }
                }
            }
            if (moved) {
                render();
                setTimeout(() => applyGravity(callback), GRAVITY_DELAY);
            } else {
                if (callback) callback();
                else setTimeout(checkFusions, 50);
            }
        }

        function applyGravityThenRespawn(twinDominos) {
            // RESPAWN D√âSACTIV√â - les dominos fusionn√©s ne reviennent plus
            applyGravity(() => {
                // Ne plus appeler respawnTwinDominos
            });
        }

        function respawnTwinDominos(twins) {
            // FONCTION D√âSACTIV√âE - conserv√©e pour r√©f√©rence
            // Les dominos fusionn√©s ne reviennent plus en jeu
            return;
        }

        function saveState() { 
            history.push(JSON.parse(JSON.stringify(dominos))); 
            scoreHistory.push(score); 
            if (history.length > MAX_HISTORY) {
                history.shift();
                scoreHistory.shift();
            }
        }
        
        function undo() { 
            if (history.length === 0 || isAnimating) return; 
            dominos = history.pop(); 
            score = scoreHistory.pop(); 
            document.getElementById('score').textContent = score.toLocaleString();
            render(); 
        }

        function resetGame() {
            if (isAnimating) return;
            history = []; scoreHistory = [];
            score = 0; comboCount = 0; lastFusionTime = 0;
            fusionCounts = { silver: 0, gold: 0, emerald: 0, cosmic: 0, supernovae: 0 };
            dominoSequenceIndex = 1;
            lastMovedIndices = [];
            
            const rng = seededRandom(LEVEL_SEEDS[currentLevel]);
            const iconKeys = getIconKeysForLevel(currentLevel);
            dominos = Array.from({ length: TOTAL }, (_, i) => {
                const { x, y } = getPos(i);
                return { 
                    face1: iconKeys[Math.floor(rng() * iconKeys.length)], 
                    face2: iconKeys[Math.floor(rng() * iconKeys.length)], 
                    rotation: ((x + y) % 2 === 0) ? 0 : 90, 
                    state: 'white' 
                };
            });
            render();
            document.getElementById('score').textContent = '0';
            document.getElementById('combo').textContent = '√ó1';
            document.getElementById('combo').style.opacity = '0.5';
            document.getElementById('silver-count').textContent = '0';
            document.getElementById('gold-count').textContent = '0';
            document.getElementById('emerald-count').textContent = '0';
            document.getElementById('cosmic-count').textContent = '0';
            document.getElementById('supernovae-count').textContent = '0';
        }
        
        function setLevel(level) {
            if (isAnimating) return;
            currentLevel = level;
            document.querySelectorAll('.level-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.level-btn')[level - 1].classList.add('active');
            resetGame();
        }
        
        function toggleNotes() {
            document.getElementById('notes-panel').classList.toggle('active');
        }
        
        function togglePointsAnimation() {
            showPointsAnimation = !showPointsAnimation;
            const btn = document.getElementById('points-anim-toggle');
            btn.classList.toggle('active', showPointsAnimation);
            try { localStorage.setItem('adam_points_anim', showPointsAnimation.toString()); } catch(e) {}
        }
        
        function toggleTwinFusion() {
            enableTwinFusion = !enableTwinFusion;
            const btn = document.getElementById('twin-toggle');
            btn.classList.toggle('active', enableTwinFusion);
            try { localStorage.setItem('adam_twin_fusion', enableTwinFusion.toString()); } catch(e) {}
        }
        
        function toggleKeepState() {
            keepStateOnRespawn = !keepStateOnRespawn;
            const btn = document.getElementById('keep-state-toggle');
            btn.classList.toggle('active', keepStateOnRespawn);
            try { localStorage.setItem('adam_keep_state', keepStateOnRespawn.toString()); } catch(e) {}
        }

        // Initialisation localStorage
        try { bestScore = parseInt(localStorage.getItem('adam_best') || '0'); document.getElementById('best').textContent = bestScore.toLocaleString(); } catch(e) {}
        try { 
            const savedAnim = localStorage.getItem('adam_points_anim');
            if (savedAnim !== null) {
                showPointsAnimation = savedAnim === 'true';
                if (showPointsAnimation) document.getElementById('points-anim-toggle').classList.add('active');
            } else {
                document.getElementById('points-anim-toggle').classList.add('active');
            }
        } catch(e) {}
        try { 
            const savedTwin = localStorage.getItem('adam_twin_fusion');
            if (savedTwin !== null) {
                enableTwinFusion = savedTwin === 'true';
                if (enableTwinFusion) document.getElementById('twin-toggle').classList.add('active');
            }
        } catch(e) {}
        try { 
            const savedKeepState = localStorage.getItem('adam_keep_state');
            if (savedKeepState !== null) {
                keepStateOnRespawn = savedKeepState === 'true';
                if (keepStateOnRespawn) document.getElementById('keep-state-toggle').classList.add('active');
            }
        } catch(e) {}
        setInterval(() => { try { localStorage.setItem('adam_best', bestScore.toString()); } catch(e) {} }, 5000);

        // Event listeners
        document.getElementById('points-anim-toggle').addEventListener('click', togglePointsAnimation);
        document.getElementById('twin-toggle').addEventListener('click', toggleTwinFusion);
        document.getElementById('keep-state-toggle').addEventListener('click', toggleKeepState);
        
        grid.addEventListener('mousedown', startDrag);
        grid.addEventListener('touchstart', startDrag, { passive: false });
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('touchmove', moveDrag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        
        // Toggle du layer menu au clic sur le logo ADAM
        document.querySelector('.logo').addEventListener('click', () => {
            document.getElementById('settings-layer').classList.toggle('active');
        });
        
        resetGame();
    </script>
</body>
</html>
