<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Cube — V11</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: #0c0d14;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .column {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            height: 100vh;
        }

        .scene {
            width: 160px;
            height: 140px;
            perspective: 700px;
            position: relative;
            touch-action: none;
        }

        .cube {
            width: 110px;
            height: 110px;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -55px;
            margin-top: -55px;
            transform-style: preserve-3d;
            transition: transform 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .face {
            position: absolute;
            width: 110px;
            height: 110px;
            border-radius: 14px;
            overflow: hidden;
            backface-visibility: hidden;
            background: #0e0f18;
            border: 1px solid rgba(126, 200, 227, 0.5);
            box-shadow:
                0 0 25px rgba(126, 200, 227, 0.08),
                inset 0 0 30px rgba(126, 200, 227, 0.04);
        }

        .face svg { width: 100%; height: 100%; display: block; }

        .face-front  { transform: rotateY(0deg)    translateZ(55px); }
        .face-back   { transform: rotateY(180deg)   translateZ(55px); }
        .face-right  { transform: rotateY(90deg)    translateZ(55px); }
        .face-left   { transform: rotateY(-90deg)   translateZ(55px); }
        .face-top    { transform: rotateX(90deg)    translateZ(55px); }
        .face-bottom { transform: rotateX(-90deg)   translateZ(55px); }

        .face svg .separator { stroke: rgba(126,200,227,0.3); stroke-width: 0.8; }
        .face svg line.icon, .face svg path.icon,
        .face svg circle.icon, .face svg rect.icon {
            stroke: #7ec8e3; stroke-width: 2;
            stroke-linecap: round; stroke-linejoin: round;
            fill: none;
            filter: drop-shadow(0 0 4px rgba(126,200,227,0.5));
        }
        .face svg circle.point {
            fill: #7ec8e3; stroke: none;
            filter: drop-shadow(0 0 4px rgba(126,200,227,0.5));
        }

        .scene.pressing .cube {
            filter: brightness(1.15);
        }
    </style>
</head>
<body>
    <div class="column">
        <div class="scene" id="scene0"><div class="cube" id="cube0"></div></div>
        <div class="scene" id="scene1"><div class="cube" id="cube1"></div></div>
        <div class="scene" id="scene2"><div class="cube" id="cube2"></div></div>
    </div>

    <script>
        const DOMINOS = [
            [`<path class="icon" d="M 20 32 L 45 12 L 70 32"/>`,
             `<circle class="icon" cx="45" cy="22" r="12"/>`],
            [`<path class="icon" d="M 10 30 Q 28 8 45 22 Q 62 36 80 14"/>`,
             `<circle class="point" cx="45" cy="12" r="4"/><circle class="point" cx="30" cy="32" r="4"/><circle class="point" cx="60" cy="32" r="4"/>`],
            [`<circle class="icon" cx="30" cy="22" r="8"/><circle class="icon" cx="60" cy="22" r="8"/>`,
             `<line class="icon" x1="25" y1="10" x2="25" y2="34"/><line class="icon" x1="45" y1="10" x2="45" y2="34"/><line class="icon" x1="65" y1="10" x2="65" y2="34"/>`],
            [`<path class="icon" d="M 45 8 L 70 22 L 45 36 L 20 22 Z"/>`,
             `<line class="icon" x1="15" y1="22" x2="75" y2="22"/>`],
            [`<path class="icon" d="M 45 8 L 70 36 L 20 36 Z"/>`,
             `<path class="icon" d="M 10 30 L 25 10 L 45 30 L 65 10 L 80 30"/>`],
            [`<circle class="point" cx="30" cy="14" r="4"/><circle class="point" cx="60" cy="14" r="4"/><circle class="point" cx="30" cy="30" r="4"/><circle class="point" cx="60" cy="30" r="4"/>`,
             `<rect class="icon" x="25" y="8" width="40" height="28" rx="3"/>`],
        ];

        const FACE_CLASSES = ['face-front','face-back','face-right','face-left','face-top','face-bottom'];

        // Normale de chaque face dans l'espace local du cube
        const FACE_NORMALS = [
            [0, 0, 1],   // front
            [0, 0, -1],  // back
            [1, 0, 0],   // right
            [-1, 0, 0],  // left
            [0, -1, 0],  // top (rotateX(90deg) => normale pointe vers -Y local)
            [0, 1, 0],   // bottom
        ];

        const FACE_ORDERS = [
            [0, 1, 2, 3, 4, 5],
            [3, 5, 0, 4, 1, 2],
            [5, 2, 4, 1, 3, 0],
        ];

        const cubes = [];

        for (let c = 0; c < 3; c++) {
            const cubeEl = document.getElementById('cube' + c);
            const sceneEl = document.getElementById('scene' + c);
            const order = FACE_ORDERS[c];
            const faceEls = [];

            order.forEach((dominoIdx, faceIdx) => {
                const pair = DOMINOS[dominoIdx];
                const face = document.createElement('div');
                face.className = 'face ' + FACE_CLASSES[faceIdx];
                face.innerHTML = `<svg viewBox="0 0 90 90">
                    <line class="separator" x1="0" y1="45" x2="90" y2="45"/>
                    <g>${pair[0]}</g>
                    <g transform="translate(0, 45)">${pair[1]}</g>
                </svg>`;
                cubeEl.appendChild(face);
                faceEls.push(face);
            });

            const state = {
                el: cubeEl,
                scene: sceneEl,
                faceEls: faceEls,
                mat: [[1,0,0],[0,1,0],[0,0,1]],
                targetMat: [[1,0,0],[0,1,0],[0,0,1]],
                transitioning: false
            };
            cubes.push(state);

            let pointerStart = null;
            let pointerMoved = false;

            sceneEl.addEventListener('pointerdown', (e) => {
                pointerStart = { x: e.clientX, y: e.clientY };
                pointerMoved = false;
                sceneEl.setPointerCapture(e.pointerId);
            });

            sceneEl.addEventListener('pointermove', (e) => {
                if (!pointerStart) return;
                if (Math.hypot(e.clientX - pointerStart.x, e.clientY - pointerStart.y) > 10) pointerMoved = true;
            });

            sceneEl.addEventListener('pointerup', (e) => {
                if (!pointerStart) return;
                const dx = e.clientX - pointerStart.x;
                const dy = e.clientY - pointerStart.y;
                const adx = Math.abs(dx), ady = Math.abs(dy);

                if (!pointerMoved || Math.max(adx, ady) < 15) {
                    spinCube(state);
                } else {
                    if (adx > ady) navigateCube(state, dx > 0 ? 'left' : 'right');
                    else navigateCube(state, dy > 0 ? 'up' : 'down');
                }
                pointerStart = null;
            });

            sceneEl.addEventListener('pointercancel', () => { pointerStart = null; });

            let accX = 0, accY = 0, cooldown = false, resetTimer = null;
            sceneEl.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (cooldown) return;
                accX += e.deltaX; accY += e.deltaY;
                clearTimeout(resetTimer);
                resetTimer = setTimeout(() => { accX = 0; accY = 0; }, 150);
                const ax = Math.abs(accX), ay = Math.abs(accY), T = 30;
                if (ax > T && ax >= ay) {
                    navigateCube(state, accX > 0 ? 'right' : 'left');
                    accX = 0; accY = 0; cooldown = true;
                    setTimeout(() => { cooldown = false; }, 400);
                } else if (ay > T) {
                    navigateCube(state, accY > 0 ? 'down' : 'up');
                    accX = 0; accY = 0; cooldown = true;
                    setTimeout(() => { cooldown = false; }, 400);
                }
            }, { passive: false });
        }

        // Matrix math
        function mul(A, B) {
            const R = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i = 0; i < 3; i++)
                for (let j = 0; j < 3; j++)
                    for (let k = 0; k < 3; k++)
                        R[i][j] += A[i][k] * B[k][j];
            return R;
        }

        function cleanMat(M) {
            return M.map(row => row.map(v => {
                const r = Math.round(v);
                return Math.abs(v - r) < 0.0001 ? r : v;
            }));
        }

        function rotX90()  { return [[ 1, 0, 0],[ 0, 0,-1],[ 0, 1, 0]]; }
        function rotXn90() { return [[ 1, 0, 0],[ 0, 0, 1],[ 0,-1, 0]]; }
        function rotY90()  { return [[ 0, 0, 1],[ 0, 1, 0],[-1, 0, 0]]; }
        function rotYn90() { return [[ 0, 0,-1],[ 0, 1, 0],[ 1, 0, 0]]; }
        function rotZn90() { return [[ 0, 1, 0],[-1, 0, 0],[ 0, 0, 1]]; }

        function matToCSS(M) {
            return `matrix3d(${M[0][0]},${M[1][0]},${M[2][0]},0,${M[0][1]},${M[1][1]},${M[2][1]},0,${M[0][2]},${M[1][2]},${M[2][2]},0,0,0,0,1)`;
        }

        // Parse matrix3d from computed style pour suivre la transition en temps réel
        function parseMatrix3d(str) {
            const match = str.match(/matrix3d\((.+)\)/);
            if (!match) return null;
            const v = match[1].split(',').map(Number);
            return [
                [v[0], v[4], v[8]],
                [v[1], v[5], v[9]],
                [v[2], v[6], v[10]],
            ];
        }

        // Transformer une normale par la matrice de rotation
        function transformNormal(mat, n) {
            return [
                mat[0][0]*n[0] + mat[0][1]*n[1] + mat[0][2]*n[2],
                mat[1][0]*n[0] + mat[1][1]*n[1] + mat[1][2]*n[2],
                mat[2][0]*n[0] + mat[2][1]*n[1] + mat[2][2]*n[2],
            ];
        }

        // Mettre à jour le halo de chaque face selon son orientation vers la caméra
        function updateGlow(state, mat) {
            state.faceEls.forEach((faceEl, idx) => {
                const normal = FACE_NORMALS[idx];
                const wn = transformNormal(mat, normal);
                // dot product avec direction caméra [0, 0, 1]
                const dot = wn[2];
                const intensity = Math.max(0, dot);

                // Halo progressif inspiré du flip-3d
                const outerR = intensity * 35;
                const outerA = intensity * 0.25;
                const midR = intensity * 15;
                const midA = intensity * 0.15;
                const innerA = intensity * 0.1;
                const borderA = 0.25 + intensity * 0.45;

                faceEl.style.boxShadow =
                    `0 0 ${outerR}px rgba(126,200,227,${outerA}),` +
                    `0 0 ${midR}px rgba(126,200,227,${midA}),` +
                    `inset 0 0 30px rgba(126,200,227,${innerA})`;
                faceEl.style.borderColor = `rgba(126,200,227,${borderA})`;
            });
        }

        // Boucle d'animation : lit le style computed pour suivre la transition CSS en temps réel
        function animateGlow() {
            cubes.forEach(state => {
                const computed = getComputedStyle(state.el).transform;
                const mat = (computed && computed !== 'none') ? parseMatrix3d(computed) : null;
                updateGlow(state, mat || state.mat);
            });
            requestAnimationFrame(animateGlow);
        }
        requestAnimationFrame(animateGlow);

        function addRotation(state, rotMatrix) {
            if (state.transitioning) return;
            state.transitioning = true;
            state.targetMat = cleanMat(mul(rotMatrix, state.targetMat));
            state.el.style.transform = matToCSS(state.targetMat);
            setTimeout(() => {
                state.mat = state.targetMat.map(r => [...r]);
                state.transitioning = false;
            }, 700);
        }

        function navigateCube(state, dir) {
            switch (dir) {
                case 'right': addRotation(state, rotYn90()); break;
                case 'left':  addRotation(state, rotY90());  break;
                case 'up':    addRotation(state, rotXn90()); break;
                case 'down':  addRotation(state, rotX90());  break;
            }
        }

        function spinCube(state) {
            addRotation(state, rotZn90());
        }

        let activeCube = cubes[1];
        cubes.forEach(state => {
            state.scene.addEventListener('pointerenter', () => { activeCube = state; });
        });

        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowRight': navigateCube(activeCube, 'right'); break;
                case 'ArrowLeft':  navigateCube(activeCube, 'left');  break;
                case 'ArrowUp':    navigateCube(activeCube, 'up');    e.preventDefault(); break;
                case 'ArrowDown':  navigateCube(activeCube, 'down');  e.preventDefault(); break;
                case ' ':          spinCube(activeCube);               e.preventDefault(); break;
            }
        });
    </script>
</body>
</html>
