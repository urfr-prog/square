<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Cube — V13</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: #0c0d14;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .grid {
            display: grid;
            grid-template-columns: 140px 140px;
            grid-template-rows: 140px 140px;
            gap: 8px;
        }

        .scene {
            width: 140px;
            height: 140px;
            perspective: 700px;
            position: relative;
            touch-action: none;
        }

        .cube {
            width: 110px;
            height: 110px;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -55px;
            margin-top: -55px;
            transform-style: preserve-3d;
            transition: transform 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .face {
            position: absolute;
            width: 110px;
            height: 110px;
            border-radius: 14px;
            overflow: hidden;
            backface-visibility: hidden;
            background: #0e0f18;
            border: 1px solid rgba(126, 200, 227, 0.5);
            box-shadow:
                0 0 25px rgba(126, 200, 227, 0.08),
                inset 0 0 30px rgba(126, 200, 227, 0.04);
        }

        .face svg { width: 100%; height: 100%; display: block; }

        .face-front  { transform: rotateY(0deg)    translateZ(55px); }
        .face-back   { transform: rotateY(180deg)   translateZ(55px); }
        .face-right  { transform: rotateY(90deg)    translateZ(55px); }
        .face-left   { transform: rotateY(-90deg)   translateZ(55px); }
        .face-top    { transform: rotateX(90deg)    translateZ(55px); }
        .face-bottom { transform: rotateX(-90deg)   translateZ(55px); }

        .face svg .separator { stroke: rgba(126,200,227,0.3); stroke-width: 0.8; }
        .face svg line.icon, .face svg path.icon,
        .face svg circle.icon, .face svg rect.icon {
            stroke: #7ec8e3; stroke-width: 2;
            stroke-linecap: round; stroke-linejoin: round;
            fill: none;
            filter: drop-shadow(0 0 4px rgba(126,200,227,0.5));
        }
        .face svg circle.point {
            fill: #7ec8e3; stroke: none;
            filter: drop-shadow(0 0 4px rgba(126,200,227,0.5));
        }
    </style>
</head>
<body>
    <div class="grid" id="grid"></div>

    <script>
        // null = face vide (pas de séparateur, pas de symbole)
        const DOMINOS = [
            [`<path class="icon" d="M 20 32 L 45 12 L 70 32"/>`,
             `<circle class="icon" cx="45" cy="22" r="12"/>`],
            [`<path class="icon" d="M 10 30 Q 28 8 45 22 Q 62 36 80 14"/>`,
             `<circle class="point" cx="45" cy="12" r="4"/><circle class="point" cx="30" cy="32" r="4"/><circle class="point" cx="60" cy="32" r="4"/>`],
            [`<circle class="icon" cx="30" cy="22" r="8"/><circle class="icon" cx="60" cy="22" r="8"/>`,
             `<line class="icon" x1="25" y1="10" x2="25" y2="34"/><line class="icon" x1="45" y1="10" x2="45" y2="34"/><line class="icon" x1="65" y1="10" x2="65" y2="34"/>`],
            [`<path class="icon" d="M 45 8 L 70 22 L 45 36 L 20 22 Z"/>`,
             `<line class="icon" x1="15" y1="22" x2="75" y2="22"/>`],
            [`<path class="icon" d="M 45 8 L 70 36 L 20 36 Z"/>`,
             `<path class="icon" d="M 10 30 L 25 10 L 45 30 L 65 10 L 80 30"/>`],
            [`<circle class="point" cx="30" cy="14" r="4"/><circle class="point" cx="60" cy="14" r="4"/><circle class="point" cx="30" cy="30" r="4"/><circle class="point" cx="60" cy="30" r="4"/>`,
             `<rect class="icon" x="25" y="8" width="40" height="28" rx="3"/>`],
        ];

        // null = face vide
        // [dominoIdx, topHalf, bottomHalf] — topHalf/bottomHalf: true=affiche, false=vide
        // On encode les faces comme [dominoIdx, showTop, showBottom]
        // Pour simplifier : on utilise null pour "face entièrement vide"
        const FACE_CLASSES = ['face-front','face-back','face-right','face-left','face-top','face-bottom'];

        const FACE_NORMALS = [
            [0, 0, 1], [0, 0, -1], [1, 0, 0], [-1, 0, 0], [0, -1, 0], [0, 1, 0],
        ];

        // Pour chaque cube : 6 faces, chaque face = [dominoIdx, showTop, showBottom] ou null (vide)
        const CUBE_FACES = [
            // Cube 0 — quelques faces vides
            [ [0, true, true], [1, true, false], null, [2, false, true], [3, true, true], null ],
            // Cube 1
            [ [4, true, true], null, [1, true, true], [0, false, true], null, [5, true, true] ],
            // Cube 2
            [ null, [2, true, true], [5, false, true], [4, true, false], [1, true, true], null ],
            // Cube 3
            [ [3, true, true], [0, true, false], null, [5, true, true], null, [2, true, true] ],
        ];

        function buildFaceSVG(faceData) {
            if (!faceData) {
                // Face vide : juste le fond, pas de contenu
                return `<svg viewBox="0 0 90 90"></svg>`;
            }
            const [dominoIdx, showTop, showBottom] = faceData;
            const pair = DOMINOS[dominoIdx];
            const sep = (showTop && showBottom) ? `<line class="separator" x1="0" y1="45" x2="90" y2="45"/>` : '';
            const top = showTop ? `<g>${pair[0]}</g>` : '';
            const bot = showBottom ? `<g transform="translate(0, 45)">${pair[1]}</g>` : '';
            return `<svg viewBox="0 0 90 90">${sep}${top}${bot}</svg>`;
        }

        const cubes = [];
        const grid = document.getElementById('grid');

        for (let c = 0; c < 4; c++) {
            const sceneEl = document.createElement('div');
            sceneEl.className = 'scene';

            const cubeEl = document.createElement('div');
            cubeEl.className = 'cube';

            sceneEl.appendChild(cubeEl);
            grid.appendChild(sceneEl);

            const faceEls = [];
            CUBE_FACES[c].forEach((faceData, faceIdx) => {
                const face = document.createElement('div');
                face.className = 'face ' + FACE_CLASSES[faceIdx];
                face.innerHTML = buildFaceSVG(faceData);
                cubeEl.appendChild(face);
                faceEls.push(face);
            });

            const state = {
                el: cubeEl,
                scene: sceneEl,
                faceEls: faceEls,
                mat: [[1,0,0],[0,1,0],[0,0,1]],
                targetMat: [[1,0,0],[0,1,0],[0,0,1]],
                transitioning: false
            };
            cubes.push(state);

            let pointerStart = null, pointerMoved = false;

            sceneEl.addEventListener('pointerdown', (e) => {
                pointerStart = { x: e.clientX, y: e.clientY };
                pointerMoved = false;
                sceneEl.setPointerCapture(e.pointerId);
            });
            sceneEl.addEventListener('pointermove', (e) => {
                if (!pointerStart) return;
                if (Math.hypot(e.clientX - pointerStart.x, e.clientY - pointerStart.y) > 10) pointerMoved = true;
            });
            sceneEl.addEventListener('pointerup', (e) => {
                if (!pointerStart) return;
                const dx = e.clientX - pointerStart.x;
                const dy = e.clientY - pointerStart.y;
                const adx = Math.abs(dx), ady = Math.abs(dy);
                if (!pointerMoved || Math.max(adx, ady) < 15) {
                    spinCube(state);
                } else {
                    if (adx > ady) navigateCube(state, dx > 0 ? 'left' : 'right');
                    else navigateCube(state, dy > 0 ? 'up' : 'down');
                }
                pointerStart = null;
            });
            sceneEl.addEventListener('pointercancel', () => { pointerStart = null; });

            let accX = 0, accY = 0, cooldown = false, resetTimer = null;
            sceneEl.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (cooldown) return;
                accX += e.deltaX; accY += e.deltaY;
                clearTimeout(resetTimer);
                resetTimer = setTimeout(() => { accX = 0; accY = 0; }, 150);
                const ax = Math.abs(accX), ay = Math.abs(accY), T = 30;
                if (ax > T && ax >= ay) {
                    navigateCube(state, accX > 0 ? 'right' : 'left');
                    accX = 0; accY = 0; cooldown = true;
                    setTimeout(() => { cooldown = false; }, 400);
                } else if (ay > T) {
                    navigateCube(state, accY > 0 ? 'down' : 'up');
                    accX = 0; accY = 0; cooldown = true;
                    setTimeout(() => { cooldown = false; }, 400);
                }
            }, { passive: false });
        }

        // Matrix math
        function mul(A, B) {
            const R = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i = 0; i < 3; i++)
                for (let j = 0; j < 3; j++)
                    for (let k = 0; k < 3; k++)
                        R[i][j] += A[i][k] * B[k][j];
            return R;
        }
        function cleanMat(M) {
            return M.map(row => row.map(v => {
                const r = Math.round(v);
                return Math.abs(v - r) < 0.0001 ? r : v;
            }));
        }
        function rotX90()  { return [[ 1, 0, 0],[ 0, 0,-1],[ 0, 1, 0]]; }
        function rotXn90() { return [[ 1, 0, 0],[ 0, 0, 1],[ 0,-1, 0]]; }
        function rotY90()  { return [[ 0, 0, 1],[ 0, 1, 0],[-1, 0, 0]]; }
        function rotYn90() { return [[ 0, 0,-1],[ 0, 1, 0],[ 1, 0, 0]]; }
        function rotZn90() { return [[ 0, 1, 0],[-1, 0, 0],[ 0, 0, 1]]; }
        function matToCSS(M) {
            return `matrix3d(${M[0][0]},${M[1][0]},${M[2][0]},0,${M[0][1]},${M[1][1]},${M[2][1]},0,${M[0][2]},${M[1][2]},${M[2][2]},0,0,0,0,1)`;
        }
        function parseMatrix3d(str) {
            const match = str.match(/matrix3d\((.+)\)/);
            if (!match) return null;
            const v = match[1].split(',').map(Number);
            return [[v[0],v[4],v[8]],[v[1],v[5],v[9]],[v[2],v[6],v[10]]];
        }
        function transformNormal(mat, n) {
            return [
                mat[0][0]*n[0]+mat[0][1]*n[1]+mat[0][2]*n[2],
                mat[1][0]*n[0]+mat[1][1]*n[1]+mat[1][2]*n[2],
                mat[2][0]*n[0]+mat[2][1]*n[1]+mat[2][2]*n[2],
            ];
        }

        function updateGlow(state, mat) {
            state.faceEls.forEach((faceEl, idx) => {
                const wn = transformNormal(mat, FACE_NORMALS[idx]);
                const intensity = Math.max(0, wn[2]);
                const outerR = intensity * 35, outerA = intensity * 0.25;
                const midR = intensity * 15, midA = intensity * 0.15;
                const innerA = intensity * 0.1;
                const borderA = 0.25 + intensity * 0.45;
                faceEl.style.boxShadow =
                    `0 0 ${outerR}px rgba(126,200,227,${outerA}),` +
                    `0 0 ${midR}px rgba(126,200,227,${midA}),` +
                    `inset 0 0 30px rgba(126,200,227,${innerA})`;
                faceEl.style.borderColor = `rgba(126,200,227,${borderA})`;
            });
        }

        function animateGlow() {
            cubes.forEach(state => {
                const computed = getComputedStyle(state.el).transform;
                const mat = (computed && computed !== 'none') ? parseMatrix3d(computed) : null;
                updateGlow(state, mat || state.mat);
            });
            requestAnimationFrame(animateGlow);
        }
        requestAnimationFrame(animateGlow);

        function addRotation(state, rotMatrix) {
            if (state.transitioning) return;
            state.transitioning = true;
            state.targetMat = cleanMat(mul(rotMatrix, state.targetMat));
            state.el.style.transform = matToCSS(state.targetMat);
            setTimeout(() => {
                state.mat = state.targetMat.map(r => [...r]);
                state.transitioning = false;
            }, 700);
        }

        // Propagation : cycle horaire right→down→left→up
        const DIR_CYCLE = ['right', 'down', 'left', 'up'];
        function pivotDir(dir, steps) {
            const idx = DIR_CYCLE.indexOf(dir);
            if (idx === -1) return dir;
            return DIR_CYCLE[(idx + steps) % 4];
        }
        function dirToRotMatrix(dir) {
            switch (dir) {
                case 'right': return rotYn90();
                case 'left':  return rotY90();
                case 'up':    return rotXn90();
                case 'down':  return rotX90();
            }
        }
        function navigateCube(sourceState, dir) {
            const sourceIdx = cubes.indexOf(sourceState);
            cubes.forEach((state, idx) => {
                const steps = (idx - sourceIdx + 4) % 4;
                addRotation(state, dirToRotMatrix(pivotDir(dir, steps)));
            });
        }
        function spinCube(state) {
            addRotation(state, rotZn90());
        }

        let activeCube = cubes[0];
        cubes.forEach(state => {
            state.scene.addEventListener('pointerenter', () => { activeCube = state; });
        });
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowRight': navigateCube(activeCube, 'right'); break;
                case 'ArrowLeft':  navigateCube(activeCube, 'left');  break;
                case 'ArrowUp':    navigateCube(activeCube, 'up');    e.preventDefault(); break;
                case 'ArrowDown':  navigateCube(activeCube, 'down');  e.preventDefault(); break;
                case ' ':          spinCube(activeCube);               e.preventDefault(); break;
            }
        });
    </script>
</body>
</html>
