<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM - Puzzle Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --cell: min(88px, 24vw);
            --gap: 0px;
        }
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        body {
            background-color: #12131a;
            min-height: 100vh; min-height: 100dvh;
            display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 6px;
        }
        
        /* Barre de score compacte avec inputs */
        .score-bar {
            display: flex; align-items: center; justify-content: space-between; gap: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(180, 180, 190, 0.2);
            border-radius: 12px; padding: 6px 12px; 
            width: calc(var(--cell) * 4 + var(--gap) * 3);
        }
        .score-item { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .score-item.compact { flex-direction: row; gap: 4px; align-items: center; }
        .score-item.with-input { flex-direction: column; gap: 2px; }
        .score-label { font-size: 0.6rem; color: rgba(180, 180, 190, 0.5); text-transform: uppercase; letter-spacing: 0.05em; }
        .score-value { font-size: 1rem; color: rgba(220, 220, 230, 0.9); font-weight: 500; font-variant-numeric: tabular-nums; }
        .score-value.small { font-size: 0.85rem; }
        .score-value.highlight { animation: scoreFlash 0.5s ease-out; }
        @keyframes scoreFlash { 0% { color: #ffd700; transform: scale(1.2); } 100% { color: rgba(220, 220, 230, 0.9); transform: scale(1); } }
        .combo { color: #34d399 !important; }
        .combo-label { color: #34d399 !important; }
        .stat-icon { font-size: 0.8rem; filter: drop-shadow(0 0 2px currentColor); }
        .stat-icon { font-size: 0.8rem; filter: drop-shadow(0 0 2px currentColor); }
        
        /* Bouton toggle animation points */
        .points-toggle {
            width: 28px; height: 28px; border-radius: 6px; border: 1px solid rgba(34, 211, 238, 0.4);
            background: rgba(34, 211, 238, 0.1); color: rgba(34, 211, 238, 0.6);
            font-size: 0.9rem; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; padding: 0;
        }
        .points-toggle:hover { border-color: rgba(34, 211, 238, 0.7); background: rgba(34, 211, 238, 0.2); }
        .points-toggle.active { 
            border-color: #22d3ee; background: rgba(34, 211, 238, 0.3); color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.4);
        }
        
        /* Conteneur pour grid et layer - AVEC OVERFLOW HIDDEN pour masquage */
        .game-container {
            position: relative;
            width: calc(var(--cell) * 4 + var(--gap) * 3);
            height: calc(var(--cell) * 6 + var(--gap) * 5);
            overflow: hidden; /* MASQUE MAGIQUE pour effet tapis roulant */
        }
        
        /* Layer menu concepteur - positionné au-dessus de la grille */
        .settings-layer {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(34, 211, 238, 0.5);
            border-radius: 12px;
            z-index: 100;
        }
        .settings-layer.active {
            display: block;
        }
        
        /* Grille - positionnement absolu des cellules */
        .grid {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(var(--cell) * 4 + var(--gap) * 3);
            height: calc(var(--cell) * 6 + var(--gap) * 5);
        }
        
        .cell {
            width: var(--cell);
            height: var(--cell);
            position: absolute;
        }
        
        .square {
            width: 100%; height: 100%; background-color: transparent;
            border: 1px solid rgba(180, 180, 190, 0.35); border-radius: 12px;
            position: absolute; top: 0; left: 0; overflow: hidden; 
            cursor: grab; user-select: none; touch-action: none;
        }
        .square:hover { border-color: rgba(180, 180, 190, 0.6); }
        .square:active { cursor: grabbing; }
        .square.empty { border: none; background: transparent; cursor: default; pointer-events: none; }
        .square.ghost { pointer-events: none; opacity: 0.9; }
        .square svg { width: 100%; height: 100%; }
        svg .separator { stroke-width: 1; stroke: rgba(180, 180, 190, 0.3); }
        svg line.icon, svg path.icon, svg circle.icon, svg rect.icon { stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; fill: none; }
        svg .domino-content { 
            transform-origin: 45px 45px; 
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        
        /* === ÉTATS 48 FACES - par icône === */
        /* BLANC */
        svg .icon.white, svg line.icon.white, svg path.icon.white, svg circle.icon.white, svg rect.icon.white { 
            stroke: rgba(180, 180, 190, 0.35); 
        }
        svg .point.white, svg circle.point.white { 
            fill: rgba(180, 180, 190, 0.35); 
        }
        
        /* ARGENT */
        svg .icon.silver, svg line.icon.silver, svg path.icon.silver, svg circle.icon.silver, svg rect.icon.silver { 
            stroke: #22d3ee; 
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); 
        }
        svg .point.silver, svg circle.point.silver { 
            fill: #22d3ee; 
            filter: drop-shadow(0 0 2px rgba(34, 211, 238, 0.4)); 
        }
        
        /* OR */
        svg .icon.gold, svg line.icon.gold, svg path.icon.gold, svg circle.icon.gold, svg rect.icon.gold { 
            stroke: #ffd700; 
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); 
        }
        svg .point.gold, svg circle.point.gold { 
            fill: #ffd700; 
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6)); 
        }
        
        /* ÉMERAUDE */
        svg .icon.emerald, svg line.icon.emerald, svg path.icon.emerald, svg circle.icon.emerald, svg rect.icon.emerald { 
            stroke: #34d399; 
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)) drop-shadow(0 0 12px rgba(5, 150, 105, 0.5)); 
        }
        svg .point.emerald, svg circle.point.emerald { 
            fill: #34d399; 
            filter: drop-shadow(0 0 6px rgba(52, 211, 153, 0.9)); 
        }
        
        /* COSMIC */
        svg .icon.cosmic, svg line.icon.cosmic, svg path.icon.cosmic, svg circle.icon.cosmic, svg rect.icon.cosmic { 
            stroke: #c4b5fd; 
            filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)) drop-shadow(0 0 10px rgba(255, 0, 110, 0.4)); 
            animation: cosmicIconShift 3s ease-in-out infinite;
        }
        svg .point.cosmic, svg circle.point.cosmic { 
            fill: #c4b5fd; 
            filter: drop-shadow(0 0 6px rgba(131, 56, 236, 0.7)); 
            animation: cosmicPointPulse 1.5s ease-in-out infinite;
        }
        
        /* SUPERNOVAE */
        svg .icon.supernovae, svg line.icon.supernovae, svg path.icon.supernovae, svg circle.icon.supernovae, svg rect.icon.supernovae { 
            stroke: #ffeb3b; 
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7)) drop-shadow(0 0 10px rgba(255, 140, 0, 0.4)); 
            animation: supernovaIconShift 2.5s ease-in-out infinite;
        }
        svg .point.supernovae, svg circle.point.supernovae { 
            fill: #ffeb3b; 
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.7)); 
            animation: supernovaPointPulse 1.2s ease-in-out infinite;
        }

        /* États du square (bordure lumineuse) */
        .square.silver { border-color: rgba(34, 211, 238, 0.6); box-shadow: inset 0 0 15px rgba(34, 211, 238, 0.15), 0 0 8px rgba(34, 211, 238, 0.3); }
        .square.gold { border-color: rgba(255, 215, 0, 0.7); box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.2), 0 0 12px rgba(255, 215, 0, 0.4); }
        .square.emerald { border-color: rgba(52, 211, 153, 0.8); box-shadow: inset 0 0 25px rgba(52, 211, 153, 0.25), 0 0 15px rgba(52, 211, 153, 0.5); }
        /* COSMIC - bordure gradient arc-en-ciel animée */
        .square.cosmic { border: 2px solid transparent; background: linear-gradient(#12131a, #12131a) padding-box, conic-gradient(from var(--cosmic-angle, 0deg), #ff006e, #8338ec, #06b6d4, #34d399, #ffd700, #ff006e) border-box; box-shadow: 0 0 25px rgba(131, 56, 236, 0.4), 0 0 40px rgba(255, 0, 110, 0.2), 0 0 50px rgba(6, 182, 212, 0.2), inset 0 0 30px rgba(131, 56, 236, 0.1); animation: cosmicRotate 4s linear infinite, cosmicPulse 2s ease-in-out infinite; }
        .square.cosmic svg .separator { stroke: rgba(196, 181, 253, 0.6); }
        /* SUPERNOVAE - bordure solaire animée */
        .square.supernovae { border: 3px solid transparent; background: linear-gradient(#12131a, #12131a) padding-box, conic-gradient(from var(--supernova-angle, 0deg), #ff4500, #ff8c00, #ffd700, #ffff00, #ff8c00, #ff4500) border-box; box-shadow: 0 0 25px rgba(255, 140, 0, 0.4), 0 0 40px rgba(255, 69, 0, 0.2), 0 0 50px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 140, 0, 0.1); animation: supernovaRotate 3s linear infinite, supernovaPulse 1.5s ease-in-out infinite; }
        .square.supernovae svg .separator { stroke: rgba(255, 235, 59, 0.6); }
        
        /* Animations cosmic */
        @property --cosmic-angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes cosmicRotate { to { --cosmic-angle: 360deg; } }
        @keyframes cosmicPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(131, 56, 236, 0.4), 0 0 40px rgba(255, 0, 110, 0.2), 0 0 50px rgba(6, 182, 212, 0.2), inset 0 0 30px rgba(131, 56, 236, 0.1); }
            50% { box-shadow: 0 0 35px rgba(131, 56, 236, 0.6), 0 0 55px rgba(255, 0, 110, 0.35), 0 0 70px rgba(6, 182, 212, 0.3), inset 0 0 40px rgba(131, 56, 236, 0.15); }
        }
        @keyframes cosmicIconShift { 0%, 100% { stroke: #c4b5fd; } 33% { stroke: #22d3ee; } 66% { stroke: #f472b6; } }
        @keyframes cosmicPointPulse { 0%, 100% { fill: #c4b5fd; } 50% { fill: #f472b6; } }
        
        /* Animations supernovae */
        @property --supernova-angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes supernovaRotate { to { --supernova-angle: 360deg; } }
        @keyframes supernovaPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(255, 140, 0, 0.4), 0 0 40px rgba(255, 69, 0, 0.2), 0 0 50px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 140, 0, 0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 140, 0, 0.6), 0 0 55px rgba(255, 69, 0, 0.35), 0 0 70px rgba(255, 215, 0, 0.3), inset 0 0 40px rgba(255, 140, 0, 0.15); }
        }
        @keyframes supernovaIconShift { 0%, 100% { stroke: #ffeb3b; } 25% { stroke: #ff8c00; } 50% { stroke: #ffd700; } 75% { stroke: #ff6347; } }
        @keyframes supernovaPointPulse { 0%, 100% { fill: #ffeb3b; } 33% { fill: #ff8c00; } 66% { fill: #ffd700; } }

        /* Animation impact */
        @keyframes impactPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
        .square.impact {
            animation: impactPulse 0.3s ease-out;
        }

        /* Contrôles en bas */
        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(180, 180, 190, 0.3);
            border-radius: 8px;
            padding: 8px 16px;
            color: rgba(220, 220, 230, 0.9);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(180, 180, 190, 0.5); }
        .btn:active { transform: scale(0.95); }
        
        .level-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .level-btn.active {
            border-color: #22d3ee;
            color: #22d3ee;
            background: rgba(34, 211, 238, 0.15);
        }
        
        /* Stats en bas */
        .stats-bar {
            display: flex;
            gap: 12px;
            font-size: 0.75rem;
            color: rgba(180, 180, 190, 0.6);
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .stat-item .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .stat-item .dot.silver { background: #22d3ee; }
        .stat-item .dot.gold { background: #ffd700; }
        .stat-item .dot.emerald { background: #34d399; }
        .stat-item .dot.cosmic { background: #c4b5fd; }
        .stat-item .dot.supernovae { background: #ff8c00; }

        /* Notes panel */
        .notes-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(18, 19, 26, 0.98);
            border: 2px solid rgba(34, 211, 238, 0.5);
            border-radius: 16px;
            padding: 20px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            color: rgba(220, 220, 230, 0.9);
        }
        .notes-panel.active { display: block; }
        .notes-panel h3 { color: #22d3ee; margin: 15px 0 10px; }
        .notes-panel h3:first-child { margin-top: 0; }
        .notes-panel p { margin: 5px 0; font-size: 0.9rem; line-height: 1.5; }
        .close-notes {
            margin-top: 15px;
            padding: 8px 20px;
            background: rgba(34, 211, 238, 0.2);
            border: 1px solid rgba(34, 211, 238, 0.5);
            border-radius: 8px;
            color: #22d3ee;
            cursor: pointer;
        }

        /* Points flottants */
        .floating-points {
            position: fixed;
            pointer-events: none;
            font-size: 1.2rem;
            font-weight: 700;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(0.8); }
        }
        
        /* Menu dans le layer */
        .settings-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
            overflow-y: auto;
        }
        .settings-content h3 {
            color: #22d3ee;
            font-size: 0.9rem;
            margin: 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(34, 211, 238, 0.3);
        }
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .settings-label {
            color: rgba(220, 220, 230, 0.8);
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <!-- Barre de score compacte -->
    <div class="score-bar">
        <div class="score-item">
            <span class="score-label">Score</span>
            <span class="score-value" id="score">0</span>
        </div>
        <div class="score-item">
            <span class="score-label">Best</span>
            <span class="score-value small" id="best">0</span>
        </div>
        <div class="score-item">
            <span class="score-label combo-label">Combo</span>
            <span class="score-value small combo" id="combo">×1</span>
        </div>
        <button class="points-toggle" id="points-anim-toggle" title="Animation points">✨</button>
    </div>
    
    <!-- Conteneur principal avec grille et layer -->
    <div class="game-container" id="game-container">
        <div class="grid" id="grid"></div>
        
        <!-- Layer menu concepteur -->
        <div class="settings-layer" id="settings-layer">
            <div class="settings-content">
                <h3>⚙️ Options</h3>
                <div class="settings-row">
                    <span class="settings-label">Animation points</span>
                    <button class="points-toggle active" id="points-anim-toggle-2" title="Animation points">✨</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Contrôles -->
    <div class="controls">
        <button class="btn" onclick="undo()">Undo</button>
        <button class="btn" onclick="resetGame()">Reset</button>
        <button class="btn level-btn active" onclick="setLevel(1)">1</button>
        <button class="btn level-btn" onclick="setLevel(2)">2</button>
        <button class="btn level-btn" onclick="setLevel(3)">3</button>
        <button class="btn level-btn" onclick="setLevel(4)">4</button>
    </div>
    
    <!-- Stats impacts par état -->
    <div class="stats-bar">
        <div class="stat-item"><div class="dot silver"></div><span id="silver-count">0</span></div>
        <div class="stat-item"><div class="dot gold"></div><span id="gold-count">0</span></div>
        <div class="stat-item"><div class="dot emerald"></div><span id="emerald-count">0</span></div>
        <div class="stat-item"><div class="dot cosmic"></div><span id="cosmic-count">0</span></div>
        <div class="stat-item"><div class="dot supernovae"></div><span id="supernovae-count">0</span></div>
    </div>
    
    <!-- Notes panel -->
    <div class="notes-panel" id="notes-panel">
        <h3>ADAM - Système d'Impact</h3>
        <p>Quand un domino en mouvement (percuteur) touche un domino immobile (percuté), si les faces en contact sont <strong>identiques</strong>, la face du percuté gagne un état.</p>
        
        <h3>Progression des états :</h3>
        <p>White → Silver → Gold → Emerald → Cosmic → Supernovae</p>
        <p>Après Supernovae, plus d'évolution possible.</p>
        
        <h3>Contrôles :</h3>
        <p><strong>Tap moitié droite :</strong> rotation +90° (horaire)</p>
        <p><strong>Tap moitié gauche :</strong> rotation -90° (antihoraire)</p>
        <p><strong>Drag horizontal :</strong> déplace toute la ligne (tapis roulant)</p>
        <p><strong>Drag vertical :</strong> déplace toute la colonne (tapis roulant)</p>
        
        <h3>Niveaux :</h3>
        <p>Chaque niveau (1, 2, 3, 4) génère une grille unique avec une séquence prédéfinie.</p>
        
        <button class="close-notes" onclick="toggleNotes()">Fermer</button>
    </div>
    
    <script>
        const COLS = 4, ROWS = 6, TOTAL = 24;
        const STATE_ORDER = ['white', 'silver', 'gold', 'emerald', 'cosmic', 'supernovae'];
        const STATE_MULTIPLIER = { white: 1, silver: 2, gold: 3, emerald: 5, cosmic: 10, supernovae: 20 };
        const POINTS = { impact: 50 };
        const MAX_HISTORY = 20;
        
        let showPointsAnimation = true;
        
        const ICONS = {
            // Face vide (pas de dessin)
            empty: { f1: '', f2: '', t: 'empty' },
            
            // Sigles niveau 1
            chevron: { f1: 'M20 32L45 12L70 32', f2: 'M20 12L45 32L70 12', t: 'path' },
            circle: { f1: '45,22,12', f2: '45,22,12', t: 'circle' },
            twoCircles: { f1: '30,22,8|60,22,8', f2: '30,22,8|60,22,8', t: 'circles' },
            line: { f1: '15,22,75,22', f2: '15,22,75,22', t: 'line' },
            threeLines: { f1: '25,10,25,34|45,10,45,34|65,10,65,34', f2: '25,10,25,34|45,10,45,34|65,10,65,34', t: 'lines' },
            twoPoints: { f1: '30,22,4|60,22,4', f2: '30,22,4|60,22,4', t: 'points' },
            square: { f1: '25,10,40,24,3', f2: '25,10,40,24,3', t: 'rect' },
            wave: { f1: 'M10 22Q28 6 45 22Q62 38 80 22', f2: 'M10 22Q28 6 45 22Q62 38 80 22', t: 'path' },
            
            // Sigles niveau 2
            twoL: { f1: 'M15 10L15 22L27 22', f2: 'M75 10L75 22L63 22', t: 'path' },
            arc: { f1: 'M20 30Q45 8 70 30', f2: 'M20 14Q45 36 70 14', t: 'path' },
            twoSquares: { f1: '24,14,12,12,2|54,14,12,12,2', f2: '24,14,12,12,2|54,14,12,12,2', t: 'rects' },
            target: { f1: '45,22,12|45,22,4', f2: '45,22,12|45,22,4', t: 'target' },
            dumbbell: { f1: '30,22,5|60,22,5|30,22,60,22', f2: '30,22,5|60,22,5|30,22,60,22', t: 'dumbbell' },
            singleLine: { f1: '45,10,45,34', f2: '45,10,45,34', t: 'line' },
            singlePoint: { f1: '45,22,5', f2: '45,22,5', t: 'circle' },
            diamond: { f1: 'M45 10L60 22L45 34L30 22Z', f2: 'M45 10L60 22L45 34L30 22Z', t: 'path' },
            
            // Sigles niveau 3
            cross: { f1: 'M45 8L45 36M29 22L61 22', f2: 'M45 8L45 36M29 22L61 22', t: 'path' },
            triangle: { f1: 'M45 10L65 34L25 34Z', f2: 'M45 34L65 10L25 10Z', t: 'path' },
            zigzag: { f1: 'M15 30L30 14L45 30L60 14L75 30', f2: 'M15 14L30 30L45 14L60 30L75 14', t: 'path' },
            brackets: { f1: 'M30 10L20 10L20 34L30 34', f2: 'M60 10L70 10L70 34L60 34', t: 'path' },
            threePoints: { f1: '30,22,4|45,22,4|60,22,4', f2: '30,22,4|45,22,4|60,22,4', t: 'points' },
            halfCircle: { f1: 'M30 30A15 15 0 0 1 60 30', f2: 'M30 14A15 15 0 0 0 60 14', t: 'path' },
            arrow: { f1: 'M20 22L70 22M55 12L70 22L55 32', f2: 'M70 22L20 22M35 12L20 22L35 32', t: 'path' },
            hexagon: { f1: 'M35 10L55 10L65 22L55 34L35 34L25 22Z', f2: 'M35 10L55 10L65 22L55 34L35 34L25 22Z', t: 'path' },
            
            // Sigles niveau 4
            miniDot: { f1: '45,22,3', f2: '45,22,3', t: 'circle' },
            twoDots: { f1: '38,22,3|52,22,3', f2: '38,22,3|52,22,3', t: 'points' },
            miniCross: { f1: 'M45 16L45 28M39 22L51 22', f2: 'M45 16L45 28M39 22L51 22', t: 'path' },
            miniSquare: { f1: '38,15,14,14,2', f2: '38,15,14,14,2', t: 'rect' },
            miniTriangle: { f1: 'M45 14L54 30L36 30Z', f2: 'M45 30L54 14L36 14Z', t: 'path' },
            slash: { f1: 'M35 30L55 14', f2: 'M35 14L55 30', t: 'path' },
            miniV: { f1: 'M35 14L45 28L55 14', f2: 'M35 30L45 16L55 30', t: 'path' },
            fourDots: { f1: '38,16,2|52,16,2|38,28,2|52,28,2', f2: '38,16,2|52,16,2|38,28,2|52,28,2', t: 'points' }
        };
        
        // Sets d'icônes par niveau
        const LEVEL_ICON_SETS = {
            1: ['chevron', 'circle', 'twoCircles', 'line', 'threeLines', 'twoPoints', 'square', 'wave'],
            2: ['twoL', 'arc', 'twoSquares', 'target', 'dumbbell', 'singleLine', 'singlePoint', 'diamond'],
            3: ['cross', 'triangle', 'zigzag', 'brackets', 'threePoints', 'halfCircle', 'arrow', 'hexagon'],
            4: ['chevron', 'circle', 'twoCircles', 'line', 'twoL', 'arc', 'twoSquares', 'target']
        };
        
        function getIconKeysForLevel(level) {
            return LEVEL_ICON_SETS[level] || LEVEL_ICON_SETS[1];
        }
        
        let dominos = [], grid = document.getElementById('grid');
        let gameContainer = document.getElementById('game-container');
        let isAnimating = false;
        let history = [], scoreHistory = [];
        let score = 0, bestScore = 0, comboCount = 0, lastImpactTime = 0;
        let currentLevel = 1;
        let impactCounts = { silver: 0, gold: 0, emerald: 0, cosmic: 0, supernovae: 0 };
        
        // Variables pour le système de drag (tapis roulant)
        let isDragging = false;
        let dragAxis = null;
        let dragRow = -1, dragCol = -1;
        let dragStartX = 0, dragStartY = 0;
        let dragStartTime = 0;
        let dragOffset = 0;
        let clickedDominoIdx = null;
        let clickLocalX = 0;
        let initialPositions = [];
        let ghostElements = [];
        let dominoElements = [];
        let lastMovedIndices = [];
        
        // Dimensions calculées
        let CELL_SIZE = 0, GAP_SIZE = 0, CELL_TOTAL = 0;
        let GRID_WIDTH = 0, GRID_HEIGHT = 0;
        
        // Configurations des 4 niveaux
        const LEVEL_SEEDS = { 1: 12345, 2: 67890, 3: 77777, 4: 99991 };
        
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 1103515245 + 12345) & 0x7fffffff;
                return state / 0x7fffffff;
            };
        }
        
        function updateDimensions() {
            CELL_SIZE = Math.min(80, window.innerWidth * 0.20);
            GAP_SIZE = 0;
            CELL_TOTAL = CELL_SIZE + GAP_SIZE;
            GRID_WIDTH = COLS * CELL_TOTAL;
            GRID_HEIGHT = ROWS * CELL_TOTAL;
        }

        function renderIcon(icon, isFace2, state = 'white') {
            if (!icon) return '';
            const d = ICONS[icon];
            if (!d) return '';
            if (d.t === 'empty') return ''; // Face vide
            const data = isFace2 ? d.f2 : d.f1;
            if (!data) return '';
            const stateClass = state || 'white';
            if (d.t === 'path') return `<path class="icon ${stateClass}" d="${data}"/>`;
            if (d.t === 'circle') { const [cx,cy,r] = data.split(','); return `<circle class="icon ${stateClass}" cx="${cx}" cy="${cy}" r="${r}"/>`; }
            if (d.t === 'line') { const [x1,y1,x2,y2] = data.split(','); return `<line class="icon ${stateClass}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`; }
            if (d.t === 'rect') { const [x,y,w,h,rx] = data.split(','); return `<rect class="icon ${stateClass}" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`; }
            if (d.t === 'rects') {
                return data.split('|').map(p => {
                    const [x,y,w,h,rx] = p.split(',');
                    return `<rect class="icon ${stateClass}" x="${x}" y="${y}" width="${w}" height="${h}" rx="${rx}"/>`;
                }).join('');
            }
            if (d.t === 'target') {
                const parts = data.split('|');
                const [cx1,cy1,r1] = parts[0].split(',');
                const [cx2,cy2,r2] = parts[1].split(',');
                return `<circle class="icon ${stateClass}" cx="${cx1}" cy="${cy1}" r="${r1}"/><circle class="point ${stateClass}" cx="${cx2}" cy="${cy2}" r="${r2}"/>`;
            }
            if (d.t === 'dumbbell') {
                const parts = data.split('|');
                const [cx1,cy1,r1] = parts[0].split(',');
                const [cx2,cy2,r2] = parts[1].split(',');
                const [x1,y1,x2,y2] = parts[2].split(',');
                return `<circle class="point ${stateClass}" cx="${cx1}" cy="${cy1}" r="${r1}"/><circle class="point ${stateClass}" cx="${cx2}" cy="${cy2}" r="${r2}"/><line class="icon ${stateClass}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`;
            }
            return data.split('|').map(p => {
                const v = p.split(',');
                return (d.t === 'circles' || d.t === 'points') 
                    ? `<circle class="${d.t === 'points' ? 'point' : 'icon'} ${stateClass}" cx="${v[0]}" cy="${v[1]}" r="${v[2]}"/>`
                    : `<line class="icon ${stateClass}" x1="${v[0]}" y1="${v[1]}" x2="${v[2]}" y2="${v[3]}"/>`;
            }).join('');
        }

        function renderDomino(d) {
            if (!d) return '';
            const rot = d.rotation || 0;
            const topState = d.topState || 'white';
            const bottomState = d.bottomState || 'white';
            const topContent = d.topIcon ? renderIcon(d.topIcon, false, topState) : '';
            const bottomContent = d.bottomIcon ? renderIcon(d.bottomIcon, true, bottomState) : '';
            return `<svg viewBox="0 0 90 90">
                <g class="domino-content" style="transform: rotate(${rot}deg)">
                    <line class="separator" x1="0" y1="45" x2="90" y2="45"/>
                    <g class="face-top" data-state="${topState}">${topContent}</g>
                    <g class="face-bottom" data-state="${bottomState}" transform="translate(0,45)">${bottomContent}</g>
                </g>
            </svg>`;
        }

        function render() {
            grid.innerHTML = '';
            dominoElements = [];
            
            CELL_SIZE = Math.min(88, window.innerWidth * 0.24);
            GAP_SIZE = 0;
            CELL_TOTAL = CELL_SIZE + GAP_SIZE;
            
            for (let i = 0; i < TOTAL; i++) {
                const col = i % COLS;
                const row = Math.floor(i / COLS);
                
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.style.left = (col * CELL_TOTAL) + 'px';
                cell.style.top = (row * CELL_TOTAL) + 'px';
                
                const div = document.createElement('div');
                div.dataset.index = i;
                
                if (dominos[i]) {
                    const d = dominos[i];
                    const topState = d.topState || 'white';
                    const bottomState = d.bottomState || 'white';
                    const topIdx = STATE_ORDER.indexOf(topState);
                    const bottomIdx = STATE_ORDER.indexOf(bottomState);
                    const dominantState = (topIdx >= bottomIdx ? topState : bottomState) || 'white';
                    div.className = `square ${dominantState}`;
                    div.innerHTML = renderDomino(d);
                } else {
                    div.className = 'square empty';
                }
                
                cell.appendChild(div);
                grid.appendChild(cell);
                dominoElements.push(div);
            }
        }

        function getPos(i) { return { x: i % COLS, y: Math.floor(i / COLS) }; }
        function getIndex(x, y) { return (x < 0 || x >= COLS || y < 0 || y >= ROWS) ? -1 : y * COLS + x; }

        // Retourne l'icône exposée dans une direction selon la rotation
        function getExposedFace(domino, dir) {
            if (!domino) return null;
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 
                0:   { top: 'top', bottom: 'bottom', left: null, right: null },
                90:  { top: null, bottom: null, left: 'bottom', right: 'top' },
                180: { top: 'bottom', bottom: 'top', left: null, right: null },
                270: { top: null, bottom: null, left: 'top', right: 'bottom' }
            };
            const faceName = map[r]?.[dir];
            if (!faceName) return null;
            return domino[faceName + 'Icon'];
        }

        // Retourne l'état de la face exposée
        function getExposedState(domino, dir) {
            if (!domino) return null;
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 
                0:   { top: 'top', bottom: 'bottom', left: null, right: null },
                90:  { top: null, bottom: null, left: 'bottom', right: 'top' },
                180: { top: 'bottom', bottom: 'top', left: null, right: null },
                270: { top: null, bottom: null, left: 'top', right: 'bottom' }
            };
            const faceName = map[r]?.[dir];
            if (!faceName) return null;
            return domino[faceName + 'State'];
        }

        // Retourne le nom de la face exposée ('top' ou 'bottom')
        function getExposedFaceName(domino, dir) {
            if (!domino) return null;
            const r = ((domino.rotation % 360) + 360) % 360;
            const map = { 
                0:   { top: 'top', bottom: 'bottom', left: null, right: null },
                90:  { top: null, bottom: null, left: 'bottom', right: 'top' },
                180: { top: 'bottom', bottom: 'top', left: null, right: null },
                270: { top: null, bottom: null, left: 'top', right: 'bottom' }
            };
            return map[r]?.[dir] || null;
        }

        // ============================================
        // ÉCHANGE DE FACES ADJACENTES + FUSION
        // ============================================
        
        function swapAdjacentFaces(idxA, idxB, dir) {
            const dominoA = dominos[idxA]; // Percuteur
            const dominoB = dominos[idxB]; // Percuté
            if (!dominoA || !dominoB) return;
            
            // Direction opposée pour B
            const oppositeDir = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };
            
            // Trouver les faces exposées
            const faceNameA = getExposedFaceName(dominoA, dir);
            const faceNameB = getExposedFaceName(dominoB, oppositeDir[dir]);
            
            // Si une des faces n'est pas exposée, pas d'échange
            if (!faceNameA || !faceNameB) return;
            
            // Récupérer les icônes avant échange
            const iconA = dominoA[faceNameA + 'Icon'];
            const iconB = dominoB[faceNameB + 'Icon'];
            
            // Si les deux faces sont vides, pas d'échange
            if (iconA === 'empty' && iconB === 'empty') return;
            
            // Échanger les icônes (y compris avec vide)
            dominoA[faceNameA + 'Icon'] = iconB;
            dominoB[faceNameB + 'Icon'] = iconA;
            
            // Échanger aussi les états
            const stateA = dominoA[faceNameA + 'State'];
            const stateB = dominoB[faceNameB + 'State'];
            dominoA[faceNameA + 'State'] = stateB;
            dominoB[faceNameB + 'State'] = stateA;
            
            // Après échange, vérifier si les faces qui se regardent sont identiques
            const newIconA = dominoA[faceNameA + 'Icon']; // ancienne iconB
            const newIconB = dominoB[faceNameB + 'Icon']; // ancienne iconA
            
            // Si identiques et non vides → Fusion !
            if (newIconA === newIconB && newIconA !== 'empty') {
                // Percuté (B) : sa face gagne un état
                const currentStateB = dominoB[faceNameB + 'State'] || 'white';
                const currentIdxB = STATE_ORDER.indexOf(currentStateB);
                if (currentIdxB < STATE_ORDER.length - 1) {
                    const newState = STATE_ORDER[currentIdxB + 1];
                    dominoB[faceNameB + 'State'] = newState;
                    
                    // Comptage
                    if (impactCounts[newState] !== undefined) {
                        impactCounts[newState]++;
                        document.getElementById(newState + '-count').textContent = impactCounts[newState];
                    }
                    
                    // Points
                    const stateBonus = { 'silver': 50, 'gold': 150, 'emerald': 400, 'cosmic': 1000, 'supernovae': 2500 };
                    addScore(stateBonus[newState] || 50);
                }
                
                // Percuteur (A) : sa face devient vide
                dominoA[faceNameA + 'Icon'] = 'empty';
                dominoA[faceNameA + 'State'] = 'white';
            }
        }

        // ============================================
        // SYSTÈME DE GHOSTS POUR WRAP-AROUND
        // ============================================
        
        function createGhosts(axis, rowOrCol) {
            clearGhosts();
            
            function getDominantState(domino) {
                const topIdx = STATE_ORDER.indexOf(domino.topState || 'white');
                const bottomIdx = STATE_ORDER.indexOf(domino.bottomState || 'white');
                return topIdx >= bottomIdx ? domino.topState : domino.bottomState;
            }
            
            if (axis === 'horizontal') {
                for (let c = 0; c < COLS; c++) {
                    const idx = rowOrCol * COLS + c;
                    const domino = dominos[idx];
                    if (!domino) continue;
                    
                    const dominantState = getDominantState(domino);
                    
                    const ghostLeft = document.createElement('div');
                    ghostLeft.className = `square ghost ${dominantState}`;
                    ghostLeft.innerHTML = renderDomino(domino);
                    ghostLeft.style.position = 'absolute';
                    ghostLeft.style.width = CELL_SIZE + 'px';
                    ghostLeft.style.height = CELL_SIZE + 'px';
                    ghostLeft.style.left = (c * CELL_TOTAL - COLS * CELL_TOTAL) + 'px';
                    ghostLeft.style.top = (rowOrCol * CELL_TOTAL) + 'px';
                    grid.appendChild(ghostLeft);
                    ghostElements.push({ el: ghostLeft, baseX: c * CELL_TOTAL - COLS * CELL_TOTAL, idx });
                    
                    const ghostRight = document.createElement('div');
                    ghostRight.className = `square ghost ${dominantState}`;
                    ghostRight.innerHTML = renderDomino(domino);
                    ghostRight.style.position = 'absolute';
                    ghostRight.style.width = CELL_SIZE + 'px';
                    ghostRight.style.height = CELL_SIZE + 'px';
                    ghostRight.style.left = (c * CELL_TOTAL + COLS * CELL_TOTAL) + 'px';
                    ghostRight.style.top = (rowOrCol * CELL_TOTAL) + 'px';
                    grid.appendChild(ghostRight);
                    ghostElements.push({ el: ghostRight, baseX: c * CELL_TOTAL + COLS * CELL_TOTAL, idx });
                }
            } else {
                for (let r = 0; r < ROWS; r++) {
                    const idx = r * COLS + rowOrCol;
                    const domino = dominos[idx];
                    if (!domino) continue;
                    
                    const dominantState = getDominantState(domino);
                    
                    const ghostTop = document.createElement('div');
                    ghostTop.className = `square ghost ${dominantState}`;
                    ghostTop.innerHTML = renderDomino(domino);
                    ghostTop.style.position = 'absolute';
                    ghostTop.style.width = CELL_SIZE + 'px';
                    ghostTop.style.height = CELL_SIZE + 'px';
                    ghostTop.style.left = (rowOrCol * CELL_TOTAL) + 'px';
                    ghostTop.style.top = (r * CELL_TOTAL - ROWS * CELL_TOTAL) + 'px';
                    grid.appendChild(ghostTop);
                    ghostElements.push({ el: ghostTop, baseY: r * CELL_TOTAL - ROWS * CELL_TOTAL, idx });
                    
                    const ghostBottom = document.createElement('div');
                    ghostBottom.className = `square ghost ${dominantState}`;
                    ghostBottom.innerHTML = renderDomino(domino);
                    ghostBottom.style.position = 'absolute';
                    ghostBottom.style.width = CELL_SIZE + 'px';
                    ghostBottom.style.height = CELL_SIZE + 'px';
                    ghostBottom.style.left = (rowOrCol * CELL_TOTAL) + 'px';
                    ghostBottom.style.top = (r * CELL_TOTAL + ROWS * CELL_TOTAL) + 'px';
                    grid.appendChild(ghostBottom);
                    ghostElements.push({ el: ghostBottom, baseY: r * CELL_TOTAL + ROWS * CELL_TOTAL, idx });
                }
            }
        }
        
        function clearGhosts() {
            ghostElements.forEach(g => g.el.remove());
            ghostElements = [];
        }

        // ============================================
        // GESTION DU DRAG (TAPIS ROULANT)
        // ============================================
        
        function startDrag(e) {
            if (isAnimating) return;
            
            const el = e.target.closest('.square');
            if (!el || el.classList.contains('ghost') || el.classList.contains('empty')) return;
            
            e.preventDefault();
            
            const idx = parseInt(el.dataset.index);
            const col = idx % COLS;
            const row = Math.floor(idx / COLS);
            
            isDragging = true;
            dragAxis = null;
            dragRow = row;
            dragCol = col;
            dragOffset = 0;
            clickedDominoIdx = idx;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragStartX = clientX;
            dragStartY = clientY;
            dragStartTime = Date.now();
            
            const rect = el.getBoundingClientRect();
            clickLocalX = clientX - rect.left;
            
            initialPositions = [];
        }
        
        function moveDrag(e) {
            if (!isDragging || isAnimating) return;
            e.preventDefault();
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const deltaX = clientX - dragStartX;
            const deltaY = clientY - dragStartY;
            
            if (dragAxis === null) {
                const threshold = 8;
                if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                    dragAxis = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                    
                    saveState();
                    
                    if (dragAxis === 'horizontal') {
                        for (let c = 0; c < COLS; c++) {
                            const idx = dragRow * COLS + c;
                            initialPositions.push({ idx, baseX: c * CELL_TOTAL });
                        }
                        createGhosts('horizontal', dragRow);
                    } else {
                        for (let r = 0; r < ROWS; r++) {
                            const idx = r * COLS + dragCol;
                            initialPositions.push({ idx, baseY: r * CELL_TOTAL });
                        }
                        createGhosts('vertical', dragCol);
                    }
                }
            }
            
            if (dragAxis === 'horizontal') {
                dragOffset = deltaX;
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (cell) {
                        cell.style.transition = 'none';
                        cell.style.left = (item.baseX + dragOffset) + 'px';
                    }
                }
                for (const ghost of ghostElements) {
                    ghost.el.style.transition = 'none';
                    ghost.el.style.left = (ghost.baseX + dragOffset) + 'px';
                }
            } else if (dragAxis === 'vertical') {
                dragOffset = deltaY;
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (cell) {
                        cell.style.transition = 'none';
                        cell.style.top = (item.baseY + dragOffset) + 'px';
                    }
                }
                for (const ghost of ghostElements) {
                    ghost.el.style.transition = 'none';
                    ghost.el.style.top = (ghost.baseY + dragOffset) + 'px';
                }
            }
        }
        
        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            
            const elapsed = Date.now() - dragStartTime;
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            const deltaX = clientX - dragStartX;
            const deltaY = clientY - dragStartY;
            const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // TAP : détection de zone (grille 3x3)
            if (dragAxis === null && elapsed < 300 && totalMovement < 10) {
                const el = dominoElements[clickedDominoIdx];
                if (el) {
                    const rect = el.getBoundingClientRect();
                    const relX = clickLocalX / rect.width;  // 0 à 1
                    const relY = (dragStartY - rect.top) / rect.height;  // 0 à 1
                    
                    // Diviser en 3 zones : 0-0.33, 0.33-0.66, 0.66-1
                    const zoneX = relX < 0.33 ? 'left' : (relX > 0.66 ? 'right' : 'center');
                    const zoneY = relY < 0.33 ? 'top' : (relY > 0.66 ? 'bottom' : 'center');
                    
                    if (zoneX === 'center' && zoneY === 'center') {
                        // Centre → Rotation horaire
                        rotateDomino(clickedDominoIdx, true);
                    } else if (zoneX === 'center' || zoneY === 'center') {
                        // Croix (haut, bas, gauche, droite) → Échange avec voisin
                        let dir = null;
                        let dx = 0, dy = 0;
                        
                        if (zoneY === 'top' && zoneX === 'center') { dir = 'top'; dy = -1; }
                        else if (zoneY === 'bottom' && zoneX === 'center') { dir = 'bottom'; dy = 1; }
                        else if (zoneX === 'left' && zoneY === 'center') { dir = 'left'; dx = -1; }
                        else if (zoneX === 'right' && zoneY === 'center') { dir = 'right'; dx = 1; }
                        
                        if (dir) {
                            const { x, y } = getPos(clickedDominoIdx);
                            const neighborIdx = getIndex(x + dx, y + dy);
                            
                            if (neighborIdx !== -1) {
                                saveState();
                                swapAdjacentFaces(clickedDominoIdx, neighborIdx, dir);
                                render();
                            }
                        }
                    }
                    // Coins → rien pour l'instant
                }
                return;
            }
            
            if (dragAxis === null) return;
            
            // Calculer le nombre de pas
            const steps = Math.round(dragOffset / CELL_TOTAL);
            
            if (steps === 0) {
                // Retour à la position initiale
                if (dragAxis === 'horizontal') {
                    for (const item of initialPositions) {
                        const cell = dominoElements[item.idx]?.parentElement;
                        if (cell) {
                            cell.style.transition = 'left 0.15s ease-out';
                            cell.style.left = item.baseX + 'px';
                        }
                    }
                } else {
                    for (const item of initialPositions) {
                        const cell = dominoElements[item.idx]?.parentElement;
                        if (cell) {
                            cell.style.transition = 'top 0.15s ease-out';
                            cell.style.top = item.baseY + 'px';
                        }
                    }
                }
                clearGhosts();
                dragAxis = null;
                initialPositions = [];
                return;
            }
            
            // Appliquer le mouvement
            if (dragAxis === 'horizontal') {
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (!cell) continue;
                    
                    let currentX = item.baseX + dragOffset;
                    const originalCol = Math.round(item.baseX / CELL_TOTAL);
                    const newCol = ((originalCol + steps) % COLS + COLS) % COLS;
                    const targetX = newCol * CELL_TOTAL;
                    
                    while (currentX - targetX > COLS * CELL_TOTAL / 2) currentX -= COLS * CELL_TOTAL;
                    while (targetX - currentX > COLS * CELL_TOTAL / 2) currentX += COLS * CELL_TOTAL;
                    
                    cell.style.transition = 'none';
                    cell.style.left = currentX + 'px';
                }
                
                grid.offsetHeight;
                
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (!cell) continue;
                    
                    const originalCol = Math.round(item.baseX / CELL_TOTAL);
                    const newCol = ((originalCol + steps) % COLS + COLS) % COLS;
                    const targetX = newCol * CELL_TOTAL;
                    
                    cell.style.transition = 'left 0.15s ease-out';
                    cell.style.left = targetX + 'px';
                }
                
                // Mettre à jour la grille logique
                const row = dragRow;
                const newRowDominos = [];
                for (let c = 0; c < COLS; c++) {
                    const sourceCol = ((c - steps) % COLS + COLS) % COLS;
                    newRowDominos[c] = dominos[row * COLS + sourceCol];
                }
                for (let c = 0; c < COLS; c++) {
                    dominos[row * COLS + c] = newRowDominos[c];
                }
                
                lastMovedIndices = [];
                for (let c = 0; c < COLS; c++) {
                    lastMovedIndices.push(row * COLS + c);
                }
                
            } else {
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (!cell) continue;
                    
                    let currentY = item.baseY + dragOffset;
                    const originalRow = Math.round(item.baseY / CELL_TOTAL);
                    const newRow = ((originalRow + steps) % ROWS + ROWS) % ROWS;
                    const targetY = newRow * CELL_TOTAL;
                    
                    while (currentY - targetY > ROWS * CELL_TOTAL / 2) currentY -= ROWS * CELL_TOTAL;
                    while (targetY - currentY > ROWS * CELL_TOTAL / 2) currentY += ROWS * CELL_TOTAL;
                    
                    cell.style.transition = 'none';
                    cell.style.top = currentY + 'px';
                }
                
                grid.offsetHeight;
                
                for (const item of initialPositions) {
                    const cell = dominoElements[item.idx]?.parentElement;
                    if (!cell) continue;
                    
                    const originalRow = Math.round(item.baseY / CELL_TOTAL);
                    const newRow = ((originalRow + steps) % ROWS + ROWS) % ROWS;
                    const targetY = newRow * CELL_TOTAL;
                    
                    cell.style.transition = 'top 0.15s ease-out';
                    cell.style.top = targetY + 'px';
                }
                
                const col = dragCol;
                const newColDominos = [];
                for (let r = 0; r < ROWS; r++) {
                    const sourceRow = ((r - steps) % ROWS + ROWS) % ROWS;
                    newColDominos[r] = dominos[sourceRow * COLS + col];
                }
                for (let r = 0; r < ROWS; r++) {
                    dominos[r * COLS + col] = newColDominos[r];
                }
                
                lastMovedIndices = [];
                for (let r = 0; r < ROWS; r++) {
                    lastMovedIndices.push(r * COLS + col);
                }
            }
            
            clearGhosts();
            
            setTimeout(() => {
                render();
                // checkImpacts('conveyor'); // GELÉ - mode échange diagonal
            }, 160);
            
            dragAxis = null;
            initialPositions = [];
        }

        // ============================================
        // ROTATION INDIVIDUELLE (TAP BIDIRECTIONNEL)
        // ============================================
        
        function rotateDomino(idx, clockwise = true) {
            const domino = dominos[idx];
            if (!domino) return;
            
            saveState();
            
            const oldRotation = domino.rotation || 0;
            domino.rotation = oldRotation + (clockwise ? 90 : -90);
            lastMovedIndices = [idx];
            
            const el = dominoElements[idx];
            if (el) {
                const contentGroup = el.querySelector('.domino-content');
                if (contentGroup) {
                    contentGroup.style.transform = `rotate(${domino.rotation}deg)`;
                }
                
                setTimeout(() => {
                    // checkImpacts('rotation'); // GELÉ - mode échange diagonal
                }, 250);
            }
        }

        // ============================================
        // SYSTÈME D'IMPACT (NOUVEAU)
        // ============================================

        function checkImpacts(source) {
            // source: 'conveyor' ou 'rotation'
            // lastMovedIndices contient les indices des dominos qui ont bougé (percuteurs)
            
            const impactedFaces = []; // { idx, faceName, newState }
            
            for (const percuteurIdx of lastMovedIndices) {
                const percuteur = dominos[percuteurIdx];
                if (!percuteur) continue;
                
                const { x, y } = getPos(percuteurIdx);
                
                // Vérifier les 4 directions
                const directions = [
                    { dir: 'top', dx: 0, dy: -1, opposite: 'bottom' },
                    { dir: 'bottom', dx: 0, dy: 1, opposite: 'top' },
                    { dir: 'left', dx: -1, dy: 0, opposite: 'right' },
                    { dir: 'right', dx: 1, dy: 0, opposite: 'left' }
                ];
                
                for (const { dir, dx, dy, opposite } of directions) {
                    const neighborIdx = getIndex(x + dx, y + dy);
                    if (neighborIdx === -1) continue;
                    
                    // Si le voisin fait partie des percuteurs, on l'ignore (il bouge aussi)
                    if (lastMovedIndices.includes(neighborIdx)) continue;
                    
                    const neighbor = dominos[neighborIdx];
                    if (!neighbor) continue;
                    
                    // Face du percuteur exposée dans cette direction
                    const percuteurFace = getExposedFace(percuteur, dir);
                    if (!percuteurFace) continue; // Pas de face exposée (domino horizontal/vertical)
                    
                    // Face du voisin exposée dans la direction opposée
                    const neighborFace = getExposedFace(neighbor, opposite);
                    if (!neighborFace) continue;
                    
                    // Si les faces sont identiques → impact !
                    if (percuteurFace === neighborFace) {
                        const neighborFaceName = getExposedFaceName(neighbor, opposite);
                        const currentState = neighbor[neighborFaceName + 'State'];
                        const currentIdx = STATE_ORDER.indexOf(currentState);
                        
                        // Si déjà supernovae, rien ne se passe
                        if (currentIdx >= STATE_ORDER.length - 1) continue;
                        
                        const newState = STATE_ORDER[currentIdx + 1];
                        
                        impactedFaces.push({
                            idx: neighborIdx,
                            faceName: neighborFaceName,
                            newState: newState
                        });
                    }
                }
            }
            
            // Appliquer les impacts
            if (impactedFaces.length > 0) {
                applyImpacts(impactedFaces);
            }
            
            // Vérifier les échanges entre dominos collés avec même liseret
            checkExchanges();
            
            lastMovedIndices = [];
        }

        function applyImpacts(impacts) {
            let totalPoints = 0;
            
            for (const { idx, faceName, newState } of impacts) {
                const domino = dominos[idx];
                if (!domino) continue;
                
                domino[faceName + 'State'] = newState;
                
                // Comptage par état
                if (impactCounts[newState] !== undefined) {
                    impactCounts[newState]++;
                    document.getElementById(newState + '-count').textContent = impactCounts[newState];
                }
                
                // Points
                const stateBonus = { 'silver': 50, 'gold': 150, 'emerald': 400, 'cosmic': 1000, 'supernovae': 2500 };
                totalPoints += stateBonus[newState] || POINTS.impact;
            }
            
            if (totalPoints > 0) {
                addScore(totalPoints);
            }
            
            // Re-render et animation
            render();
            
            // Animation d'impact sur les dominos touchés
            for (const { idx } of impacts) {
                const el = dominoElements[idx];
                if (el) {
                    el.classList.add('impact');
                    setTimeout(() => el.classList.remove('impact'), 300);
                }
            }
        }

        // ============================================
        // SYSTÈME D'ÉCHANGE AUTOMATIQUE
        // Deux dominos collés avec même liseret peuvent échanger une face
        // ============================================

        function getDominantState(domino) {
            if (!domino) return 'white';
            const topIdx = STATE_ORDER.indexOf(domino.topState || 'white');
            const bottomIdx = STATE_ORDER.indexOf(domino.bottomState || 'white');
            return topIdx >= bottomIdx ? (domino.topState || 'white') : (domino.bottomState || 'white');
        }

        function checkExchanges() {
            let exchangeHappened = false;
            const processed = new Set(); // Éviter les doubles traitements
            
            for (let idx = 0; idx < TOTAL; idx++) {
                const dominoA = dominos[idx];
                if (!dominoA) continue;
                
                const stateA = getDominantState(dominoA);
                if (stateA === 'white') continue; // Pas d'échange pour les blancs
                
                const { x, y } = getPos(idx);
                
                // Vérifier les 4 voisins
                const neighbors = [
                    { dx: 1, dy: 0 },  // droite
                    { dx: 0, dy: 1 },  // bas
                    { dx: -1, dy: 0 }, // gauche
                    { dx: 0, dy: -1 }  // haut
                ];
                
                for (const { dx, dy } of neighbors) {
                    const neighborIdx = getIndex(x + dx, y + dy);
                    if (neighborIdx === -1) continue;
                    
                    // Éviter de traiter la même paire deux fois
                    const pairKey = [idx, neighborIdx].sort().join('-');
                    if (processed.has(pairKey)) continue;
                    processed.add(pairKey);
                    
                    const dominoB = dominos[neighborIdx];
                    if (!dominoB) continue;
                    
                    const stateB = getDominantState(dominoB);
                    
                    // Même liseret (même état dominant) et pas blanc
                    if (stateA === stateB && stateA !== 'white') {
                        // Chercher un échange bénéfique
                        if (tryExchange(idx, neighborIdx, stateA)) {
                            exchangeHappened = true;
                        }
                    }
                }
            }
            
            if (exchangeHappened) {
                render();
            }
        }

        function tryExchange(idxA, idxB, targetState) {
            const dominoA = dominos[idxA];
            const dominoB = dominos[idxB];
            if (!dominoA || !dominoB) return false;
            
            const targetStateIdx = STATE_ORDER.indexOf(targetState);
            
            // Trouver une face de A qui n'est PAS dans l'état cible
            // et une face de B qui EST dans l'état cible
            
            const facesA = [
                { name: 'top', icon: dominoA.topIcon, state: dominoA.topState },
                { name: 'bottom', icon: dominoA.bottomIcon, state: dominoA.bottomState }
            ];
            
            const facesB = [
                { name: 'top', icon: dominoB.topIcon, state: dominoB.topState },
                { name: 'bottom', icon: dominoB.bottomIcon, state: dominoB.bottomState }
            ];
            
            // Chercher : A veut une face de B qui match son état cible
            // A donne en retour une face qui ne match pas
            
            for (const faceA of facesA) {
                const faceAStateIdx = STATE_ORDER.indexOf(faceA.state || 'white');
                // Cette face de A n'est pas dans l'état cible (candidate à être donnée)
                if (faceAStateIdx < targetStateIdx) {
                    for (const faceB of facesB) {
                        const faceBStateIdx = STATE_ORDER.indexOf(faceB.state || 'white');
                        // Cette face de B EST dans l'état cible (candidate à être prise)
                        if (faceBStateIdx >= targetStateIdx && faceB.icon === faceA.icon) {
                            // Même icône ! Échange possible
                            // A prend l'état de B, B prend l'état de A
                            
                            const tempState = faceA.state;
                            dominoA[faceA.name + 'State'] = faceB.state;
                            dominoB[faceB.name + 'State'] = tempState;
                            
                            return true;
                        }
                    }
                }
            }
            
            // Aussi essayer l'inverse : B veut une face de A
            for (const faceB of facesB) {
                const faceBStateIdx = STATE_ORDER.indexOf(faceB.state || 'white');
                if (faceBStateIdx < targetStateIdx) {
                    for (const faceA of facesA) {
                        const faceAStateIdx = STATE_ORDER.indexOf(faceA.state || 'white');
                        if (faceAStateIdx >= targetStateIdx && faceA.icon === faceB.icon) {
                            const tempState = faceB.state;
                            dominoB[faceB.name + 'State'] = faceA.state;
                            dominoA[faceA.name + 'State'] = tempState;
                            
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        function addScore(points) {
            const now = Date.now();
            if (now - lastImpactTime < 2000 && lastImpactTime > 0) comboCount++;
            else comboCount = 1;
            lastImpactTime = now;
            
            const comboMultiplier = 1 + (comboCount - 1) * 0.5;
            const finalPoints = Math.round(points * comboMultiplier);
            score += finalPoints;
            if (score > bestScore) bestScore = score;
            
            updateScoreDisplay();
            
            // Points flottants
            if (showPointsAnimation) {
                const gridRect = grid.getBoundingClientRect();
                showFloatingPoints(finalPoints, gridRect.left + gridRect.width/2, gridRect.top + gridRect.height/2);
            }
            
            return finalPoints;
        }

        function updateScoreDisplay() {
            const scoreEl = document.getElementById('score');
            const comboEl = document.getElementById('combo');
            const bestEl = document.getElementById('best');
            scoreEl.textContent = score.toLocaleString();
            scoreEl.classList.remove('highlight'); void scoreEl.offsetWidth; scoreEl.classList.add('highlight');
            comboEl.textContent = comboCount > 1 ? `×${(1 + (comboCount - 1) * 0.5).toFixed(1)}` : '×1';
            comboEl.style.opacity = comboCount > 1 ? '1' : '0.5';
            bestEl.textContent = bestScore.toLocaleString();
        }

        function showFloatingPoints(points, x, y) {
            if (!showPointsAnimation) return;
            const el = document.createElement('div');
            el.className = 'floating-points';
            el.textContent = `+${points.toLocaleString()}`;
            el.style.left = `${x}px`; el.style.top = `${y}px`;
            el.style.color = 'rgba(255, 255, 255, 0.9)';
            el.style.textShadow = '0 0 8px rgba(255, 255, 255, 0.6)';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function saveState() { 
            history.push(JSON.parse(JSON.stringify(dominos))); 
            scoreHistory.push(score); 
            if (history.length > MAX_HISTORY) {
                history.shift();
                scoreHistory.shift();
            }
        }
        
        function undo() { 
            if (history.length === 0 || isAnimating) return; 
            dominos = history.pop(); 
            score = scoreHistory.pop(); 
            document.getElementById('score').textContent = score.toLocaleString();
            render(); 
        }

        function resetGame() {
            if (isAnimating) return;
            history = []; scoreHistory = [];
            score = 0; comboCount = 0; lastImpactTime = 0;
            impactCounts = { silver: 0, gold: 0, emerald: 0, cosmic: 0, supernovae: 0 };
            lastMovedIndices = [];
            
            const rng = seededRandom(LEVEL_SEEDS[currentLevel]);
            const iconKeys = getIconKeysForLevel(currentLevel);
            dominos = Array.from({ length: TOTAL }, (_, i) => {
                const { x, y } = getPos(i);
                return { 
                    topIcon: iconKeys[Math.floor(rng() * iconKeys.length)],
                    topState: 'white',
                    bottomIcon: iconKeys[Math.floor(rng() * iconKeys.length)],
                    bottomState: 'white',
                    rotation: ((x + y) % 2 === 0) ? 0 : 90
                };
            });
            render();
            document.getElementById('score').textContent = '0';
            document.getElementById('combo').textContent = '×1';
            document.getElementById('combo').style.opacity = '0.5';
            document.getElementById('silver-count').textContent = '0';
            document.getElementById('gold-count').textContent = '0';
            document.getElementById('emerald-count').textContent = '0';
            document.getElementById('cosmic-count').textContent = '0';
            document.getElementById('supernovae-count').textContent = '0';
        }
        
        function setLevel(level) {
            if (isAnimating) return;
            currentLevel = level;
            document.querySelectorAll('.level-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.level-btn')[level - 1].classList.add('active');
            resetGame();
        }
        
        function toggleNotes() {
            document.getElementById('notes-panel').classList.toggle('active');
        }
        
        function togglePointsAnimation() {
            showPointsAnimation = !showPointsAnimation;
            const btn = document.getElementById('points-anim-toggle');
            const btn2 = document.getElementById('points-anim-toggle-2');
            btn.classList.toggle('active', showPointsAnimation);
            btn2.classList.toggle('active', showPointsAnimation);
            try { localStorage.setItem('adam_points_anim', showPointsAnimation.toString()); } catch(e) {}
        }

        // Initialisation localStorage
        try { bestScore = parseInt(localStorage.getItem('adam_best') || '0'); document.getElementById('best').textContent = bestScore.toLocaleString(); } catch(e) {}
        try { 
            const savedAnim = localStorage.getItem('adam_points_anim');
            if (savedAnim !== null) {
                showPointsAnimation = savedAnim === 'true';
                if (showPointsAnimation) {
                    document.getElementById('points-anim-toggle').classList.add('active');
                    document.getElementById('points-anim-toggle-2').classList.add('active');
                }
            } else {
                document.getElementById('points-anim-toggle').classList.add('active');
                document.getElementById('points-anim-toggle-2').classList.add('active');
            }
        } catch(e) {}
        setInterval(() => { try { localStorage.setItem('adam_best', bestScore.toString()); } catch(e) {} }, 5000);

        // Event listeners
        document.getElementById('points-anim-toggle').addEventListener('click', togglePointsAnimation);
        document.getElementById('points-anim-toggle-2').addEventListener('click', togglePointsAnimation);
        
        grid.addEventListener('mousedown', startDrag);
        grid.addEventListener('touchstart', startDrag, { passive: false });
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('touchmove', moveDrag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        
        resetGame();
    </script>
</body>
</html>
